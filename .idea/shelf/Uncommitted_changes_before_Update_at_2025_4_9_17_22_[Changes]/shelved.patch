Index: docs/src/model/GameState.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {Inventory} from \"./Inventory.js\";\r\nimport {Tornado1PlayBoard} from \"./stages/Tor1.js\";\r\nimport {Tornado2PlayBoard} from \"./stages/Tor2.js\";\r\nimport {Volcano1PlayBoard} from \"./stages/Vol1.js\";\r\nimport {LanguageManager} from \"../LanguageManager.js\";\r\nimport {Tornado3PlayBoard} from \"./stages/Tor3.js\";\r\nimport {Tornado4PlayBoard} from \"./stages/Tor4.js\";\r\nimport {Tornado5PlayBoard} from \"./stages/Tor5.js\";\r\nimport {Earthquake1PlayBoard} from \"./stages/Ear1.js\";\r\nimport {Blizzard1PlayBoard} from \"./stages/Bli1.js\";\r\nimport {Tsunami1PlayBoard} from \"./stages/Tsu1.js\";\r\n\r\nexport const stateCode = {\r\n    MENU: 1,\r\n    STANDBY: 2,\r\n    MAP: 3,\r\n    PLAY: 4,\r\n    FINISH: 8\r\n};\r\n\r\n// game stages are now grouped and the code refers to affiliated group\r\n// the game stage factory, combining with this.clearedStages handles which concrete stage to be allocated.\r\nexport const stageGroup = {\r\n    NO_STAGE: 0,\r\n    TORNADO: 1,     // 5 stages expected\r\n    VOLCANO: 2,     // 1\r\n    EARTHQUAKE: 4,  // 5?\r\n    BLIZZARD: 8,   // 5?\r\n    TSUNAMI: 16     // 1\r\n}\r\n\r\n// game state should not handle any switching logic but only stores information\r\nexport class GameState {\r\n    constructor(p5) {\r\n        this.state = stateCode.MENU; // default\r\n        this.currentStageGroup = stageGroup.NO_STAGE; // no stage is selected\r\n        this.currentStage = null;\r\n        this.inventory = new Inventory(p5);\r\n        this.playerCanClick = true; // set this to false during end turn enemy activity\r\n        this.paused = false;\r\n        this.clearedStages = new Map();\r\n\r\n        this.gsf = new GameStageFactory();\r\n        this.languageManager = new LanguageManager();\r\n        this.showOptions = false;\r\n    }\r\n\r\n    setState(newState) {\r\n        console.log(`Game state changed to: ${Object.keys(stateCode).find(key => stateCode[key] === newState)}`);\r\n        this.state = newState;\r\n    }\r\n\r\n    getState() {\r\n        return this.state;\r\n    }\r\n\r\n    setPlayerCanClick(bool) {\r\n        this.playerCanClick = bool;\r\n    }\r\n\r\n    togglePaused() {\r\n        this.paused = !this.paused;\r\n    }\r\n\r\n    setStageCleared(playBoard) {\r\n        if (this.clearedStages.has(playBoard.stageGroup)) {\r\n            this.clearedStages.set(playBoard.stageGroup, this.clearedStages.get(playBoard.stageGroup) + 1);\r\n        } else {\r\n            this.clearedStages.set(playBoard.stageGroup, 1);\r\n        }\r\n    }\r\n\r\n    isStageCleared(stageGroup) {\r\n        let index = this.clearedStages.get(stageGroup);\r\n        return index !== undefined && index >= this.gsf.stageClasses[stageGroup].length;\r\n    }\r\n\r\n    isSpecificStageCleared(stageGroup, numbering) {\r\n        let index = this.clearedStages.get(stageGroup);\r\n        return index !== undefined && index >= numbering;\r\n    }\r\n\r\n    // invoked by controller.\r\n    newGameStage() {\r\n        return this.gsf.newGameStage(this.currentStageGroup, this);\r\n    }\r\n}\r\n\r\nclass GameStageFactory {\r\n    constructor() {\r\n        this.stageClasses = Array.from({length: 20}, () => []);\r\n        this.stageClasses[stageGroup.TORNADO].push(Tornado1PlayBoard);\r\n        this.stageClasses[stageGroup.TORNADO].push(Tornado2PlayBoard);\r\n        this.stageClasses[stageGroup.TORNADO].push(Tornado3PlayBoard);\r\n        this.stageClasses[stageGroup.TORNADO].push(Tornado4PlayBoard);\r\n        this.stageClasses[stageGroup.TORNADO].push(Tornado5PlayBoard);\r\n\r\n        this.stageClasses[stageGroup.VOLCANO].push(Volcano1PlayBoard);\r\n\r\n        this.stageClasses[stageGroup.EARTHQUAKE].push(Earthquake1PlayBoard);\r\n\r\n        this.stageClasses[stageGroup.BLIZZARD].push(Blizzard1PlayBoard);\r\n\r\n        this.stageClasses[stageGroup.TSUNAMI].push(Tsunami1PlayBoard);\r\n    }\r\n\r\n    // allocate game stage dynamically\r\n    newGameStage(newStage, gameState) {\r\n        let StageClasses = this.stageClasses[gameState.currentStageGroup];\r\n        let index = gameState.clearedStages.get(gameState.currentStageGroup);\r\n        let StageClass = StageClasses[index != null ? index : 0];\r\n        return StageClass ? new StageClass(gameState) : null;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/model/GameState.js b/docs/src/model/GameState.js
--- a/docs/src/model/GameState.js	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ b/docs/src/model/GameState.js	(date 1744215531304)
@@ -13,7 +13,6 @@
 export const stateCode = {
     MENU: 1,
     STANDBY: 2,
-    MAP: 3,
     PLAY: 4,
     FINISH: 8
 };
@@ -24,9 +23,9 @@
     NO_STAGE: 0,
     TORNADO: 1,     // 5 stages expected
     VOLCANO: 2,     // 1
-    EARTHQUAKE: 4,  // 5?
-    BLIZZARD: 8,   // 5?
-    TSUNAMI: 16     // 1
+    EARTHQUAKE: 3,  // 5?
+    BLIZZARD: 4,   // 5?
+    TSUNAMI: 5,     // 1
 }
 
 // game state should not handle any switching logic but only stores information
@@ -39,6 +38,7 @@
         this.playerCanClick = true; // set this to false during end turn enemy activity
         this.paused = false;
         this.clearedStages = new Map();
+        this.clearedStages.set(stageGroup.NO_STAGE, 1);
 
         this.gsf = new GameStageFactory();
         this.languageManager = new LanguageManager();
@@ -89,6 +89,7 @@
 class GameStageFactory {
     constructor() {
         this.stageClasses = Array.from({length: 20}, () => []);
+
         this.stageClasses[stageGroup.TORNADO].push(Tornado1PlayBoard);
         this.stageClasses[stageGroup.TORNADO].push(Tornado2PlayBoard);
         this.stageClasses[stageGroup.TORNADO].push(Tornado3PlayBoard);
Index: docs/src/controller/input.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {stateCode} from \"../model/GameState.js\";\r\n\r\nexport class InputHandler {\r\n    constructor(controller) {\r\n        this.controller = controller;\r\n        this.keys = [];\r\n        this.keyboradKeys = [];\r\n        this.gamepadKeys = [];\r\n        this.gamepad;\r\n        window.addEventListener('keydown', e => {\r\n            if ((e.key === 'w' ||\r\n                    e.key === 'a' ||\r\n                    e.key === 's' ||\r\n                    e.key === 'd' ||\r\n                    e.key === 'Enter' ||\r\n                    e.key === ' ')\r\n                && this.keyboradKeys.indexOf(e.key) === -1) {\r\n                this.keyboradKeys.push(e.key);\r\n            } else if (e.key === 'q') {\r\n                //\r\n            } else if (e.key === 'Escape' && this.gameState.state === stateCode.PLAY) {\r\n                // pause the game\r\n                this.gameState.togglePaused();\r\n                // comment out since code change\r\n                //this.gameState.togglePlayerCanClick();\r\n            }\r\n        });\r\n        window.addEventListener('keyup', e => {\r\n            if (e.key === 'w' ||\r\n                e.key === 'a' ||\r\n                e.key === 's' ||\r\n                e.key === 'd' ||\r\n                e.key === 'Enter' ||\r\n                e.key === ' ') {\r\n                this.keyboradKeys.splice(this.keyboradKeys.indexOf(e.key), 1);\r\n            }\r\n        });\r\n\r\n        window.addEventListener('gamepadconnected', (e) => {\r\n            this.gamepad = e.gamepad;\r\n        });\r\n\r\n        window.addEventListener('gamepaddisconnected', (e) => {\r\n            this.gamepad = null;\r\n        });\r\n    }\r\n\r\n    updateGamepad() {\r\n        if (this.gamepad) {\r\n            const gamepads = navigator.getGamepads();\r\n            const gamepad = gamepads[this.gamepad.index];\r\n\r\n            if (gamepad) {\r\n                const axisX = gamepad.axes[0];\r\n\r\n                if (axisX > 0.5 && !this.gamepadKeys.includes('d')) {\r\n                    this.gamepadKeys.push('d');\r\n                } else if (axisX < -0.5 && !this.gamepadKeys.includes('a')) {\r\n                    this.gamepadKeys.push('a');\r\n                } else if (Math.abs(axisX) < 0.5 && (this.gamepadKeys.includes('a') || this.gamepadKeys.includes('d'))) {\r\n                    this.gamepadKeys.splice(this.gamepadKeys.indexOf('a'), 1);\r\n                    this.gamepadKeys.splice(this.gamepadKeys.indexOf('d'), 1);\r\n                }\r\n\r\n                if (gamepad.buttons[0].pressed && !this.gamepadKeys.includes(' ')) {\r\n                    this.gamepadKeys.push(' ');\r\n                } else if (!gamepad.buttons[0].pressed && this.gamepadKeys.includes(' ')) {\r\n                    this.gamepadKeys.splice(this.gamepadKeys.indexOf(' '), 1);\r\n                }\r\n\r\n                if (gamepad.buttons[12].pressed) this.controller.menus[stateCode.MENU].moveSelection(-1, 0);\r\n                if (gamepad.buttons[13].pressed) this.controller.menus[stateCode.MENU].moveSelection(-1, 0);\r\n            }\r\n            this.keys = [...new Set([...this.keyboradKeys, ...this.gamepadKeys])];\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/controller/input.js b/docs/src/controller/input.js
--- a/docs/src/controller/input.js	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ b/docs/src/controller/input.js	(date 1744215531300)
@@ -18,7 +18,7 @@
                 this.keyboradKeys.push(e.key);
             } else if (e.key === 'q') {
                 //
-            } else if (e.key === 'Escape' && this.gameState.state === stateCode.PLAY) {
+            } else if (e.key === 'Escape' && this.gameState.state !== stateCode.MENU) {
                 // pause the game
                 this.gameState.togglePaused();
                 // comment out since code change
Index: docs/src/model/InfoBox.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {myutil} from \"../../lib/myutil.js\";\r\nimport {Button} from \"../items/Button.js\";\r\n\r\nexport class InfoBox {\r\n    constructor(playBoard) {\r\n        this.infoStatus = 't'; // by default prints terrain & ( enemy | seed )\r\n        this.recordStatus = 't'; // if record!='a' && status = 'a', init button, vice versa.\r\n        this.activateButton = null;\r\n        this.displayButton = null;\r\n\r\n        this.playBoard = playBoard;\r\n        [this.boxWidth, this.boxHeight] = myutil.relative2absolute(0.18, 1 / 4);\r\n        this.boxX = myutil.relative2absolute(1 / 128, 0)[0];\r\n        [this.paddingX, this.paddingY] = myutil.relative2absolute(1 / 128, 1 / 72);\r\n        this.boxY = this.playBoard.canvasHeight - this.boxHeight - this.paddingY;\r\n    }\r\n\r\n    // left bottom info box\r\n    draw(p5) {\r\n        p5.fill(50);\r\n        p5.noStroke();\r\n        p5.rect(this.boxX, this.boxY, this.boxWidth, this.boxHeight, 10); // 10: corner roundness\r\n\r\n        let title;\r\n        let info;\r\n\r\n        if (this.infoStatus === 't') {\r\n            title = \"General Info\";\r\n            info = this.playBoard.boardObjects.getCellString(this.playBoard.selectedCell[0], this.playBoard.selectedCell[1]);\r\n        } else if (this.infoStatus === 'p') {\r\n            title = \"Plant Passive\";\r\n            info = this.playBoard.boardObjects.getCell(this.playBoard.selectedCell[0], this.playBoard.selectedCell[1]).plant.getPassiveString();\r\n        } else if (this.infoStatus === 'a') {\r\n            title = \"Plant Active\";\r\n            info = this.playBoard.boardObjects.getCell(this.playBoard.selectedCell[0], this.playBoard.selectedCell[1]).plant.getActiveString();\r\n        } else if (this.infoStatus === 'e') {\r\n            title = \"Ecosystem\";\r\n            info = this.playBoard.boardObjects.getCell(this.playBoard.selectedCell[0], this.playBoard.selectedCell[1]).getEcoString(this.playBoard);\r\n        }\r\n\r\n        p5.fill(255);\r\n        p5.textSize(20);\r\n        p5.textAlign(p5.CENTER, p5.TOP);\r\n        p5.text(title, this.boxX + this.boxWidth / 2, this.boxY + this.paddingY);\r\n\r\n        p5.textSize(18);\r\n        p5.textAlign(p5.LEFT, p5.TOP);\r\n        p5.textWrap(p5.WORD);\r\n        p5.text(info, this.boxX + this.paddingX, this.boxY + this.paddingY + 24, this.boxWidth - this.paddingX * 2);\r\n\r\n        let arrowSize = myutil.relative2absolute(0.02)[0];\r\n        p5.image(p5.images.get(\"leftarrow\"), this.boxX + this.boxWidth / 3 - arrowSize / 2, this.boxY - arrowSize - this.paddingY, arrowSize, arrowSize);\r\n        p5.image(p5.images.get(\"rightarrow\"), this.boxX + 2 * this.boxWidth / 3 - arrowSize / 2, this.boxY - arrowSize - this.paddingY, arrowSize, arrowSize);\r\n\r\n        // draw a box to highlight arrow\r\n        if (this.boxX + this.boxWidth / 3 - arrowSize / 2 < p5.mouseX && p5.mouseX < this.boxX + this.boxWidth / 3 - arrowSize / 2 + arrowSize\r\n            && this.boxY - arrowSize - this.paddingY < p5.mouseY && p5.mouseY < this.boxY - arrowSize - this.paddingY + arrowSize) {\r\n            p5.fill(0, 0, 0, 0);\r\n            p5.stroke(100);\r\n            p5.strokeWeight(2);\r\n            p5.rect(this.boxX + this.boxWidth / 3 - arrowSize / 2, this.boxY - arrowSize - this.paddingY, arrowSize, arrowSize);\r\n        }\r\n        if (this.boxX + 2 * this.boxWidth / 3 - arrowSize / 2 < p5.mouseX && p5.mouseX < this.boxX + 2 * this.boxWidth / 3 - arrowSize / 2 + arrowSize\r\n            && this.boxY - arrowSize - this.paddingY < p5.mouseY && p5.mouseY < this.boxY - arrowSize - this.paddingY + arrowSize) {\r\n            p5.fill(0, 0, 0, 0);\r\n            p5.stroke(100);\r\n            p5.strokeWeight(2);\r\n            p5.rect(this.boxX + 2 * this.boxWidth / 3 - arrowSize / 2, this.boxY - arrowSize - this.paddingY, arrowSize, arrowSize);\r\n        }\r\n\r\n        // add a page indicator\r\n        let cell = this.playBoard.boardObjects.getCell(this.playBoard.selectedCell[0], this.playBoard.selectedCell[1]);\r\n        let pages;\r\n        let currentPage;\r\n        if (cell.plant === null) {\r\n            pages = 2;\r\n            switch (this.infoStatus) {\r\n                case 't':\r\n                    currentPage = 1;\r\n                    break;\r\n                case 'e':\r\n                    currentPage = 2;\r\n                    break;\r\n                default:\r\n                    currentPage = 1;\r\n                    break;\r\n            }\r\n        } else {\r\n            pages = 4;\r\n            switch (this.infoStatus) {\r\n                case 't':\r\n                    currentPage = 1;\r\n                    break;\r\n                case 'p':\r\n                    currentPage = 2;\r\n                    break;\r\n                case 'a':\r\n                    currentPage = 3;\r\n                    break;\r\n                case 'e':\r\n                    currentPage = 4;\r\n                    break;\r\n                default:\r\n                    currentPage = 1;\r\n                    break;\r\n            }\r\n        }\r\n        p5.textSize(18);\r\n        p5.fill(255);\r\n        p5.noStroke();\r\n        p5.textAlign(p5.LEFT, p5.TOP);\r\n        p5.text(`${currentPage}/${pages}`, this.boxX + this.boxWidth / 2 - arrowSize / 2, this.boxY - 2 * arrowSize / 3 - this.paddingY);\r\n    }\r\n\r\n    // clicked info box arrows when info box exists in play board\r\n    handleClickArrow(p5, playBoard) {\r\n        if (playBoard.selectedCell.length !== 0) {\r\n            if (playBoard.infoBox.clickArrow(p5, this)) {\r\n                return true;\r\n            } else {\r\n                // reset the info status to prevent unintentional bugs\r\n                playBoard.infoBox.resetStatus();\r\n                playBoard.infoBox.deleteActivateButton(p5, this);\r\n                playBoard.infoBox.deleteDisplayButton(p5);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    clickArrow(p5) {\r\n        // the parameters of arrows are hardcoded now, should refactor later.\r\n        let leftArrowX = 74;\r\n        let rightArrowX = 150.8;\r\n        let arrowY = 494.4;\r\n        let arrowSize = 25.6;\r\n        if (p5.mouseX >= leftArrowX && p5.mouseX < leftArrowX + arrowSize\r\n            && p5.mouseY >= arrowY && p5.mouseY <= arrowY + arrowSize) {\r\n            return this.clickLeftArrow(p5);\r\n        }\r\n        if (p5.mouseX >= rightArrowX && p5.mouseX < rightArrowX + arrowSize\r\n            && p5.mouseY >= arrowY && p5.mouseY <= arrowY + arrowSize) {\r\n            return this.clickRightArrow(p5);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // separate the two functions to incorporate keyboard shortcut\r\n    clickLeftArrow(p5) {\r\n        this.infoBoxFSM(p5, 'p');\r\n        return true;\r\n    }\r\n\r\n    clickRightArrow(p5) {\r\n        this.infoBoxFSM(p5, 'n');\r\n        return true;\r\n    }\r\n\r\n    // a finite state machine.\r\n    infoBoxFSM(p5, nextOrPrev) {\r\n        let cell = this.playBoard.boardObjects.getCell(this.playBoard.selectedCell[0], this.playBoard.selectedCell[1]);\r\n\r\n        // terrain & enemy\r\n        if (this.infoStatus === 't') {\r\n            if (nextOrPrev === 'n') {\r\n                if (cell.plant !== null) {\r\n                    this.setStatus(p5, 'p');\r\n                } else {\r\n                    this.setStatus(p5, 'e');\r\n                }\r\n            } else {\r\n                this.setStatus(p5, 'e');\r\n            }\r\n        }\r\n\r\n        // plant passive skill\r\n        else if (this.infoStatus === 'p') {\r\n            if (nextOrPrev === 'n') {\r\n                this.setStatus(p5, 'a');\r\n            } else {\r\n                this.setStatus(p5, 't');\r\n            }\r\n        }\r\n\r\n        // plant active skill\r\n        else if (this.infoStatus === 'a') {\r\n            if (nextOrPrev === 'n') {\r\n                this.setStatus(p5, 'e');\r\n            } else {\r\n                this.setStatus(p5, 'p');\r\n            }\r\n        }\r\n\r\n        // ecosystem\r\n        else if (this.infoStatus === 'e') {\r\n            if (nextOrPrev === 'n') {\r\n                this.setStatus(p5, 't');\r\n            } else {\r\n                if (cell.plant !== null) {\r\n                    this.setStatus(p5, 'a');\r\n                } else {\r\n                    this.setStatus(p5, 't');\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    setStatus(p5, newStatus) {\r\n        this.infoStatus = newStatus;\r\n        let cell = this.playBoard.boardObjects.getCell(this.playBoard.selectedCell[0], this.playBoard.selectedCell[1]);\r\n        if (this.infoStatus === 'a' && this.recordStatus !== 'a' && cell.plant !== null && cell.plant.hasActive) {\r\n            this.setActivateButton(p5);\r\n        } else if (this.infoStatus !== 'a' && this.recordStatus === 'a') {\r\n            this.deleteActivateButton(p5);\r\n        }\r\n\r\n        if (this.infoStatus === 'e') this.setEcoDisplayButton(p5);\r\n        else this.deleteDisplayButton(p5);\r\n\r\n        this.recordStatus = newStatus;\r\n    }\r\n\r\n    resetStatus() {\r\n        this.infoStatus = 't';\r\n        this.recordStatus = 't';\r\n    }\r\n\r\n    setActivateButton(p5) {\r\n        let [buttonWidth, buttonHeight] = myutil.relative2absolute(5 / 64, 0.04);\r\n        let buttonX = this.boxX + this.boxWidth / 2 - buttonWidth / 2;\r\n        let buttonY = this.playBoard.canvasHeight - buttonHeight - 2 * this.paddingY;\r\n        let activate = new Button(buttonX, buttonY, buttonWidth, buttonHeight, \"activate\");\r\n        activate.onClick = () => {\r\n            this.playBoard.activatePlantSkill(p5);\r\n        };\r\n        this.playBoard.buttons.push(activate);\r\n        this.activateButton = activate;\r\n    }\r\n\r\n    deleteActivateButton(p5) {\r\n        if (this.activateButton === null) {\r\n            return;\r\n        }\r\n        let index = this.playBoard.buttons.findIndex(button => button === this.activateButton);\r\n        if (index !== -1) {\r\n            this.playBoard.buttons.splice(index, 1);\r\n        }\r\n        this.activateButton = null;\r\n    }\r\n\r\n    setEcoDisplayButton(p5) {\r\n        let [buttonWidth, buttonHeight] = myutil.relative2absolute(5 / 64, 0.04);\r\n        let buttonX = this.boxX + this.boxWidth / 2 - buttonWidth / 2;\r\n        let buttonY = this.playBoard.canvasHeight - buttonHeight - 2 * this.paddingY;\r\n\r\n        let text = this.playBoard.ecoDisplay ? \"display off\" : \"display on\";\r\n\r\n        let display = new Button(buttonX, buttonY, buttonWidth, buttonHeight, text);\r\n        display.onClick = () => {\r\n            this.playBoard.ecoDisplay = !this.playBoard.ecoDisplay;\r\n            this.toggleEcoDisplayButtonText();\r\n        };\r\n        this.playBoard.buttons.push(display);\r\n        this.displayButton = display;\r\n    }\r\n\r\n    toggleEcoDisplayButtonText() {\r\n        this.displayButton.text = this.playBoard.ecoDisplay ? \"display off\" : \"display on\";\r\n    }\r\n\r\n    deleteDisplayButton(p5) {\r\n        if (this.displayButton === null) return;\r\n\r\n        let index = this.playBoard.buttons.findIndex(button => button === this.displayButton);\r\n        if (index !== -1) {\r\n            this.playBoard.buttons.splice(index, 1);\r\n        }\r\n        this.displayButton = null;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/model/InfoBox.js b/docs/src/model/InfoBox.js
--- a/docs/src/model/InfoBox.js	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ b/docs/src/model/InfoBox.js	(date 1744215531305)
@@ -12,7 +12,7 @@
         [this.boxWidth, this.boxHeight] = myutil.relative2absolute(0.18, 1 / 4);
         this.boxX = myutil.relative2absolute(1 / 128, 0)[0];
         [this.paddingX, this.paddingY] = myutil.relative2absolute(1 / 128, 1 / 72);
-        this.boxY = this.playBoard.canvasHeight - this.boxHeight - this.paddingY;
+        this.boxY = myutil.relative2absolute(1, 1)[1] - this.boxHeight - this.paddingY;
     }
 
     // left bottom info box
Index: docs/src/model/Inventory.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {Tree, TreeSeed} from \"../items/Tree.js\";\r\nimport {Bush, BushSeed} from \"../items/Bush.js\";\r\nimport {Orchid, OrchidSeed} from \"../items/Orchid.js\";\r\nimport {CanvasSize} from \"../CanvasSize.js\";\r\nimport {myutil} from \"../../lib/myutil.js\"\r\nimport {itemTypes, plantTypes, seedTypes} from \"../items/ItemTypes.js\";\r\nimport {FireHerb, FireHerbSeed} from \"../items/FireHerb.js\";\r\nimport {Bamboo, BambooSeed} from \"../items/Bamboo.js\";\r\nimport {Plum, PlumSeed} from \"../items/Blizzard.js\";\r\nimport {Kiku, KikuSeed} from \"../items/Kiku.js\";\r\n\r\nexport class Inventory {\r\n    constructor(p5) {\r\n        this.items = new Map(); // <String name, int count>\r\n        this.selectedItem = null; // a String\r\n        this.scrollIndex = 0;\r\n        this.maxVisibleItems = 6;\r\n        this.status = [false, false, false, false, false, false];\r\n        this.index = 0;\r\n\r\n        // for fast lookup when creating item\r\n        this.itemPrototypes = this.initPrototypes(p5); // Map<String name, Plant/Seed instance>\r\n\r\n        // inventory and item parameters\r\n        [this.padding, this.itemHeight] = myutil.relative2absolute(0.01, 0.06);\r\n        [this.inventoryWidth, this.inventoryY] = myutil.relative2absolute(0.1, 0.03);\r\n        this.itemInter = myutil.relative2absolute(0.01, 0.01)[1];\r\n        this.inventoryHeight = Math.min(this.items.size, this.maxVisibleItems) * this.itemHeight + this.padding * 2;\r\n        this.inventoryX = CanvasSize.getSize()[0] - this.inventoryWidth - this.padding;\r\n        this.itemX = this.inventoryX + this.padding;\r\n        this.itemWidth = this.inventoryWidth - this.padding * 4;\r\n    }\r\n\r\n    // with prototypes, we can find seed or plant type given a name,\r\n    // while name is a concrete String rather than a reference\r\n    // so we can create it multiple times.\r\n    initPrototypes(p5) {\r\n        return new Map([\r\n            [\"Tree\", new Tree(p5)],\r\n            [\"Bush\", new Bush(p5)],\r\n            [\"Orchid\", new Orchid(p5)],\r\n            [\"FireHerb\", new FireHerb(p5)],\r\n            [\"Bamboo\", new Bamboo(p5)],\r\n            [\"Plum\", new Plum(p5)],\r\n            [\"Kiku\", new Kiku(p5)],\r\n            [\"TreeSeed\", new TreeSeed(p5)],\r\n            [\"BushSeed\", new BushSeed(p5)],\r\n            [\"OrchidSeed\", new OrchidSeed(p5)],\r\n            [\"FireHerbSeed\", new FireHerbSeed(p5)],\r\n            [\"BambooSeed\", new BambooSeed(p5)],\r\n            [\"PlumSeed\", new PlumSeed(p5)],\r\n            [\"KikuSeed\", new KikuSeed(p5)],\r\n        ]);\r\n    }\r\n\r\n    draw(p5) {\r\n        p5.noStroke();\r\n        // Inventory background\r\n        p5.fill(100);\r\n        p5.rect(this.inventoryX, this.inventoryY, this.inventoryWidth, this.inventoryHeight, 10);\r\n\r\n        // Inventory title text\r\n        p5.fill(255);\r\n        p5.textAlign(p5.CENTER, p5.CENTER);\r\n        p5.textSize(14);\r\n        p5.text(\"Inventory\", this.inventoryX + this.inventoryWidth / 2, this.inventoryY + this.padding);\r\n\r\n        // loop inventory items\r\n        let visibleItems = Array.from(this.items.entries()).slice(this.scrollIndex, this.scrollIndex + this.maxVisibleItems);\r\n        let index = 0;\r\n        for (let i = 0; i < visibleItems.length; i++) {\r\n            let key = visibleItems[i][0];\r\n            let value = visibleItems[i][1];\r\n            let itemY = this.inventoryY + this.padding * 2 + index * this.itemHeight;\r\n            let itemInstance = this.itemPrototypes.get(key);\r\n            if (this.index === i) {\r\n                p5.stroke(255, 0, 0);\r\n                p5.strokeWeight(4);\r\n            } else {\r\n                p5.stroke(255, 255, 255);\r\n            }\r\n            p5.fill(itemInstance.color);\r\n            p5.rect(this.itemX, itemY, this.itemWidth, this.itemHeight - this.itemInter, this.itemInter);\r\n            p5.fill(0);\r\n            p5.textSize(14);\r\n            p5.textAlign(p5.CENTER, p5.CENTER);\r\n            p5.text(itemInstance.name, this.inventoryX + this.itemWidth / 2 + this.padding, itemY + (this.itemHeight - this.itemInter) / 2);\r\n            p5.text(value, this.inventoryX + this.inventoryWidth - (this.inventoryWidth - (this.itemWidth + this.padding)) / 2, itemY + (this.itemHeight - this.itemInter) / 2);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    handleScroll(event) {\r\n        let maxIndex = Math.max(0, this.items.size - this.maxVisibleItems);\r\n        if (event.deltaY > 0) {\r\n            this.scrollIndex = Math.min(this.scrollIndex + 1, maxIndex);\r\n        } else if (event.deltaY < 0) {\r\n            this.scrollIndex = Math.max(this.scrollIndex - 1, 0);\r\n        }\r\n    }\r\n\r\n    handleClick(p5) {\r\n        // clear item when clicked somewhere else\r\n        this.selectedItem = null;\r\n\r\n        let visibleItems = Array.from(this.items.entries()).slice(this.scrollIndex, this.scrollIndex + this.maxVisibleItems);\r\n        // record when an inventory item is clicked\r\n        let index = 0;\r\n        for (let [key, value] of visibleItems) {\r\n            let itemY = this.inventoryY + this.padding * 2 + index * this.itemHeight;\r\n            if (p5.mouseX >= this.itemX && p5.mouseX <= this.itemX + this.itemWidth &&\r\n                p5.mouseY >= itemY && p5.mouseY <= itemY + (this.itemHeight - this.itemInter)) {\r\n                this.selectedItem = key;\r\n                return;\r\n            }\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // invoke this function when an item from inventory is placed to playing board\r\n    itemDecrement() {\r\n        if (this.selectedItem === null || !this.items.has(this.selectedItem)) {\r\n            return;\r\n        }\r\n\r\n        // update data\r\n        let value = this.items.get(this.selectedItem) - 1;\r\n        if (value === 0) {\r\n            this.items.delete(this.selectedItem);\r\n        } else {\r\n            this.items.set(this.selectedItem, value);\r\n        }\r\n        this.selectedItem = null;\r\n\r\n        // update inventory height after decreasing\r\n        this.updateInventoryHeight();\r\n    }\r\n\r\n    // return a new item according to its name.\r\n    // use prototypes for type lookup and creation\r\n    createItem(p5, name) {\r\n        // fetch an instance from item prototypes\r\n        let item = this.itemPrototypes.get(name);\r\n        if (item === null) {\r\n            console.error(\"input of createItem is unknown?\");\r\n            return null;\r\n        }\r\n\r\n        return new item.constructor(p5);\r\n    }\r\n\r\n    // add item into the inventory.\r\n    pushItem2Inventory(p5, name, quantity) {\r\n        // if the item is already in inventory:\r\n        if (this.items.has(name)) {\r\n            this.items.set(name, this.items.get(name) + quantity);\r\n            return;\r\n        }\r\n        // if the item is not in inventory:\r\n        if (this.createItem(p5, name) !== null) {\r\n            this.items.set(name, quantity);\r\n        }\r\n        // if the item is invalid:\r\n        // do nothing. createItem has printed error info.\r\n\r\n        // update inventory height after pushing:\r\n        this.updateInventoryHeight();\r\n    }\r\n\r\n    // to set item to a specific number.\r\n    setItemOfInventory(p5, name, quantity) {\r\n        this.items.set(name, quantity);\r\n        this.updateInventoryHeight();\r\n    }\r\n\r\n    // store inventory items so next method can load it\r\n    saveInventory() {\r\n        let tmpItems = new Map();\r\n        for (let [key, value] of this.items.entries()) {\r\n            tmpItems.set(key, value);\r\n        }\r\n        return tmpItems;\r\n    }\r\n\r\n    // load saved inventory items when quit a stage\r\n    loadInventory(tmpItems) {\r\n        this.items = new Map();\r\n        for (let [key, value] of tmpItems.entries()) {\r\n            this.items.set(key, value);\r\n        }\r\n        this.updateInventoryHeight();\r\n    }\r\n\r\n    // update inventory height after insertion or delete\r\n    // and secretly sort items by type. may want to refactor\r\n    updateInventoryHeight() {\r\n        this.inventoryHeight = Math.min(this.items.size, this.maxVisibleItems) * this.itemHeight + this.padding * 2;\r\n\r\n        this.items = new Map([...this.items].sort(([key1], [key2]) => {\r\n            let instance1 = this.itemPrototypes.get(key1);\r\n            let instance2 = this.itemPrototypes.get(key2);\r\n            const type1 = \"plantType\" in instance1 ? instance1.plantType : instance1.seedType;\r\n            const type2 = \"plantType\" in instance2 ? instance2.plantType : instance2.seedType;\r\n            return type1 - type2;\r\n        }))\r\n    }\r\n\r\n    // when a stage is cleared, remove all seeds and bamboo from inventory.\r\n    removeAllSeedsAndBamboo() {\r\n        for (let [name, instance] of this.itemPrototypes.entries()) {\r\n            if (instance.type === itemTypes.SEED) {\r\n                this.items.delete(name);\r\n            }\r\n            if (instance.type === itemTypes.PLANT && instance.plantType === plantTypes.BAMBOO) {\r\n                this.items.delete(name);\r\n            }\r\n        }\r\n        this.updateInventoryHeight();\r\n    }\r\n\r\n    stringify() {\r\n        const object = {\r\n            items: Array.from(this.items.entries())\r\n        }\r\n        return JSON.stringify(object);\r\n    }\r\n\r\n    static parse(json, p5) {\r\n        const object = JSON.parse(json);\r\n        let inv = new Inventory(p5);\r\n        inv.items = new Map(object.items);\r\n        inv.updateInventoryHeight();\r\n        return inv;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/model/Inventory.js b/docs/src/model/Inventory.js
--- a/docs/src/model/Inventory.js	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ b/docs/src/model/Inventory.js	(date 1744215531305)
@@ -8,6 +8,7 @@
 import {Bamboo, BambooSeed} from "../items/Bamboo.js";
 import {Plum, PlumSeed} from "../items/Blizzard.js";
 import {Kiku, KikuSeed} from "../items/Kiku.js";
+import {Palm, PalmSeed} from "../items/Palm.js";
 
 export class Inventory {
     constructor(p5) {
@@ -43,6 +44,7 @@
             ["Bamboo", new Bamboo(p5)],
             ["Plum", new Plum(p5)],
             ["Kiku", new Kiku(p5)],
+            ["Palm", new Palm(p5)],
             ["TreeSeed", new TreeSeed(p5)],
             ["BushSeed", new BushSeed(p5)],
             ["OrchidSeed", new OrchidSeed(p5)],
@@ -50,13 +52,14 @@
             ["BambooSeed", new BambooSeed(p5)],
             ["PlumSeed", new PlumSeed(p5)],
             ["KikuSeed", new KikuSeed(p5)],
+            ["PalmSeed", new PalmSeed(p5)],
         ]);
     }
 
     draw(p5) {
         p5.noStroke();
         // Inventory background
-        p5.fill(100);
+        p5.fill(100, 100, 100, 200);
         p5.rect(this.inventoryX, this.inventoryY, this.inventoryWidth, this.inventoryHeight, 10);
 
         // Inventory title text
Index: docs/src/model/Menu.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {Button} from \"../items/Button.js\";\r\nimport {stateCode} from \"./GameState.js\";\r\nimport {myutil} from \"../../lib/myutil.js\";\r\nimport {GameSave} from \"./GameSave.js\";\r\nimport {LanguageManager} from \"../LanguageManager.js\";\r\nimport {MenuItem} from \"../items/MenuItem.js\";\r\n\r\nexport class StartMenu {\r\n    constructor(gameState) {\r\n        this.gameState = gameState;\r\n        this.buttons = [];\r\n        this.languageManager = this.gameState.languageManager;\r\n        this.interactives = Array.from({length: 5},\r\n            () => Array.from({length: 5}, () => null));\r\n        this.row = 0;\r\n        this.col = 0;\r\n        this.x = 640;\r\n        this.y = 360;\r\n    }\r\n\r\n    setup(p5) {\r\n\r\n        let [buttonWidth, buttonHeight] = myutil.relative2absolute(0.15, 0.07);\r\n        let [buttonX, buttonY] = myutil.relative2absolute(0.2, 0.6);\r\n        let buttonInter = myutil.relative2absolute(0.1, 0.1)[1];\r\n\r\n        let newGameButton = new MenuItem(buttonX - buttonWidth / 2, buttonY, buttonWidth, buttonHeight, this.languageManager.getText('newGame'));\r\n        newGameButton.onClick = () => this.gameState.setState(stateCode.STANDBY);\r\n\r\n\r\n        let optionsButton = new MenuItem(buttonX - buttonWidth / 2, buttonY + buttonInter, buttonWidth, buttonHeight, this.languageManager.getText('options'));\r\n        optionsButton.onClick = () => {\r\n            this.gameState.showOptions = !this.gameState.showOptions;\r\n        }\r\n\r\n        let continueButton = new MenuItem(buttonX - buttonWidth / 2, buttonY + 2 * buttonInter, buttonWidth, buttonHeight, \"Other\");\r\n\r\n        this.buttons.push(newGameButton, optionsButton, continueButton);\r\n        this.setupInteractive();\r\n    }\r\n\r\n    reset(p5) {\r\n        this.buttons = [];\r\n        this.setup(p5);\r\n    }\r\n\r\n    handleClick(p5) {\r\n        for (let button of this.buttons) {\r\n            button.mouseClick(p5);\r\n        }\r\n    }\r\n\r\n    draw(p5) {\r\n        p5.background(50);\r\n        p5.fill(255);\r\n        p5.textSize(32);\r\n        p5.textAlign(p5.CENTER, p5.TOP);\r\n        let [textX, textY] = myutil.relative2absolute(0.5, 0.1);\r\n        p5.text(this.languageManager.getText('startMenu'), textX, textY);\r\n\r\n        for (let button of this.buttons) {\r\n            if (button.update) {\r\n                button.update(p5);\r\n            }\r\n            button.draw(p5);\r\n        }\r\n\r\n        p5.circle(this.x, this.y, 10);\r\n    }\r\n\r\n    changeNewToResume() {\r\n        let newGameButton = this.buttons.find(button => button.text.startsWith(\"New Game\"));\r\n        if (newGameButton !== null && newGameButton !== undefined) {\r\n            newGameButton.text = \"Resume Game\";\r\n        }\r\n    }\r\n\r\n    updateText() {\r\n        this.buttons[0].text = this.languageManager.getText('newGame');\r\n        this.buttons[1].text = this.languageManager.getText('loadGame');\r\n        this.buttons[2].text = this.languageManager.getText('options');\r\n    }\r\n\r\n    setupInteractive() {\r\n        this.interactives[0][0] = this.buttons[0];\r\n        this.interactives[1][0] = this.buttons[1];\r\n        this.interactives[2][0] = this.buttons[2];\r\n    }\r\n\r\n    moveSelection(dRow, dCol) {\r\n        let newRow = Math.max(0, Math.min(this.row + dRow, this.interactives.length - 1));\r\n        let newCol = Math.max(0, Math.min(this.col + dCol, this.interactives[newRow].length - 1));\r\n\r\n        if(this.interactives[newRow][newCol]){\r\n            this.interactives[this.row][this.col].isSelected = false;\r\n            this.row = newRow;\r\n            this.col = newCol;\r\n            this.interactives[newRow][newCol].isSelected = true;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/model/Menu.js b/docs/src/model/Menu.js
--- a/docs/src/model/Menu.js	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ b/docs/src/model/Menu.js	(date 1744215671251)
@@ -1,42 +1,39 @@
-import {Button} from "../items/Button.js";
-import {stateCode} from "./GameState.js";
+import {stageGroup, stateCode} from "./GameState.js";
 import {myutil} from "../../lib/myutil.js";
 import {GameSave} from "./GameSave.js";
-import {LanguageManager} from "../LanguageManager.js";
 import {MenuItem} from "../items/MenuItem.js";
+import {FloatingWindow} from "./FloatingWindow.js";
+import {Screen} from "./Screen.js";
 
-export class StartMenu {
+export class StartMenu extends Screen {
     constructor(gameState) {
-        this.gameState = gameState;
-        this.buttons = [];
+        super(gameState);
         this.languageManager = this.gameState.languageManager;
-        this.interactives = Array.from({length: 5},
-            () => Array.from({length: 5}, () => null));
-        this.row = 0;
-        this.col = 0;
-        this.x = 640;
-        this.y = 360;
     }
 
     setup(p5) {
+        this.initAllFloatingWindows(p5);
 
         let [buttonWidth, buttonHeight] = myutil.relative2absolute(0.15, 0.07);
         let [buttonX, buttonY] = myutil.relative2absolute(0.2, 0.6);
         let buttonInter = myutil.relative2absolute(0.1, 0.1)[1];
 
-        let newGameButton = new MenuItem(buttonX - buttonWidth / 2, buttonY, buttonWidth, buttonHeight, this.languageManager.getText('newGame'));
+        let newGameButton = new MenuItem(buttonX - buttonWidth / 2, buttonY, buttonWidth, buttonHeight, "New Game");
         newGameButton.onClick = () => this.gameState.setState(stateCode.STANDBY);
 
+        let loadGameButton = new MenuItem(buttonX - buttonWidth / 2, buttonY + buttonInter, buttonWidth, buttonHeight, "Load Game");
+        loadGameButton.onClick = () => {
+            if (!GameSave.load(p5)) {
+                this.copyFloatingWindow(p5, "NoSaveData");
+            }
+        }
 
-        let optionsButton = new MenuItem(buttonX - buttonWidth / 2, buttonY + buttonInter, buttonWidth, buttonHeight, this.languageManager.getText('options'));
+        let optionsButton = new MenuItem(buttonX - buttonWidth / 2, buttonY + 2 * buttonInter, buttonWidth, buttonHeight, "Options");
         optionsButton.onClick = () => {
             this.gameState.showOptions = !this.gameState.showOptions;
         }
 
-        let continueButton = new MenuItem(buttonX - buttonWidth / 2, buttonY + 2 * buttonInter, buttonWidth, buttonHeight, "Other");
-
-        this.buttons.push(newGameButton, optionsButton, continueButton);
-        this.setupInteractive();
+        this.buttons.push(newGameButton, loadGameButton, optionsButton);
     }
 
     reset(p5) {
@@ -45,6 +42,9 @@
     }
 
     handleClick(p5) {
+        if (this.handleFloatingWindow()) {
+            return;
+        }
         for (let button of this.buttons) {
             button.mouseClick(p5);
         }
@@ -65,7 +65,7 @@
             button.draw(p5);
         }
 
-        p5.circle(this.x, this.y, 10);
+        this.drawFloatingWindow(p5);
     }
 
     changeNewToResume() {
@@ -81,24 +81,20 @@
         this.buttons[2].text = this.languageManager.getText('options');
     }
 
-    setupInteractive() {
-        this.interactives[0][0] = this.buttons[0];
-        this.interactives[1][0] = this.buttons[1];
-        this.interactives[2][0] = this.buttons[2];
+    copyFloatingWindow(p5, str) {
+        this.floatingWindow = FloatingWindow.copyOf(this.allFloatingWindows.get(str));
+    }
+
+    setFloatingWindow(p5) {
     }
 
-    moveSelection(dRow, dCol) {
-        let newRow = Math.max(0, Math.min(this.row + dRow, this.interactives.length - 1));
-        let newCol = Math.max(0, Math.min(this.col + dCol, this.interactives[newRow].length - 1));
+    initAllFloatingWindows(p5) {
+        let afw = new Map();
 
-        if(this.interactives[newRow][newCol]){
-            this.interactives[this.row][this.col].isSelected = false;
-            this.row = newRow;
-            this.col = newCol;
-            this.interactives[newRow][newCol].isSelected = true;
-        }
+        myutil.commonFloatingWindows(p5, afw);
+
+        this.allFloatingWindows = afw;
     }
-
 }
 
 
Index: docs/src/model/Options.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {Button} from \"../items/Button.js\";\r\nimport {myutil} from \"../../lib/myutil.js\";\r\nimport {GameSave} from \"./GameSave.js\";\r\nimport {GameState, stateCode} from \"./GameState.js\";\r\nimport {LanguageManager} from \"../LanguageManager.js\";\r\nimport {CanvasSize} from \"../CanvasSize.js\";\r\nimport {Checkbox} from \"../items/Checkbox.js\";\r\n\r\nexport class Options {\r\n    constructor(controller) {\r\n        this.controller = controller;\r\n        this.buttons = [];\r\n        this.languageManager = this.controller.gameState.languageManager;\r\n    }\r\n\r\n    setup(p5) {\r\n\r\n        let [buttonWidth, buttonHeight] = myutil.relative2absolute(0.10, 0.05);\r\n        let [buttonX, buttonY] = myutil.relative2absolute(0.5, 0.3);\r\n        let buttonInter = myutil.relative2absolute(0.1, 0.1)[1];\r\n\r\n        let englishButton = new Button(buttonX - buttonWidth / 2, buttonY, buttonWidth, buttonHeight, 'English');\r\n        englishButton.onClick = () => {\r\n            this.languageManager.setLanguage('en');\r\n            this.controller.menus[stateCode.MENU].updateText();\r\n        }\r\n\r\n        let chineseButton = new Button(buttonX - buttonWidth / 2, buttonY + buttonInter, buttonWidth, buttonHeight, '简体中文');\r\n        chineseButton.onClick = () => {\r\n            this.languageManager.setLanguage('zh');\r\n            this.controller.menus[stateCode.MENU].updateText();\r\n        }\r\n\r\n        let [checkboxWidth, checkboxHeight] = myutil.relative2absolute(0.001 * 9, 0.001 * 16);\r\n        let fullScreenCheckbox = new Checkbox(buttonX - buttonWidth / 2, buttonY + 2 * buttonInter, checkboxWidth, checkboxHeight, 'Fullscreen');\r\n        fullScreenCheckbox.onClick = () => {\r\n            if(fullScreenCheckbox.isChecked){\r\n                myutil.exitFullscreen();\r\n                p5.resizeCanvas(1280, 720);\r\n                CanvasSize.setSize(1280, 720);\r\n                this.controller.reset(p5);\r\n            }\r\n            else{\r\n                let screenWidth = window.screen.width;\r\n                let screenHeight = window.screen.height;\r\n                myutil.enterFullscreen();\r\n                p5.resizeCanvas(screenWidth, screenHeight);\r\n                CanvasSize.setSize(screenWidth, screenHeight);\r\n                this.controller.reset(p5);\r\n            }\r\n            fullScreenCheckbox.isChecked = !fullScreenCheckbox.isChecked;\r\n        }\r\n        this.buttons.push(englishButton, chineseButton, fullScreenCheckbox);\r\n    }\r\n\r\n    reset(p5){\r\n\r\n    }\r\n\r\n    handleClick(p5) {\r\n        for (let button of this.buttons) {\r\n            if (button.mouseClick(p5)) {\r\n                // this.controller.gameState.showOptions = !this.controller.gameState.showOptions;\r\n                return;\r\n            }\r\n        }\r\n        this.controller.gameState.showOptions = !this.controller.gameState.showOptions;\r\n    }\r\n\r\n    handleKey() {\r\n\r\n    }\r\n\r\n    draw(p5) {\r\n        p5.background(0, 0, 0, 80);\r\n        p5.fill(255);\r\n        p5.textSize(50);\r\n        p5.textAlign(p5.CENTER, p5.CENTER);\r\n        let [textX, textY] = myutil.relative2absolute(0.5, 0.2);\r\n        p5.text(\"Options\", textX, textY);\r\n\r\n        for (let button of this.buttons) {\r\n            button.draw(p5);\r\n        }\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/model/Options.js b/docs/src/model/Options.js
--- a/docs/src/model/Options.js	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ b/docs/src/model/Options.js	(date 1744215531306)
@@ -1,8 +1,6 @@
 import {Button} from "../items/Button.js";
 import {myutil} from "../../lib/myutil.js";
-import {GameSave} from "./GameSave.js";
 import {GameState, stateCode} from "./GameState.js";
-import {LanguageManager} from "../LanguageManager.js";
 import {CanvasSize} from "../CanvasSize.js";
 import {Checkbox} from "../items/Checkbox.js";
 
@@ -34,13 +32,12 @@
         let [checkboxWidth, checkboxHeight] = myutil.relative2absolute(0.001 * 9, 0.001 * 16);
         let fullScreenCheckbox = new Checkbox(buttonX - buttonWidth / 2, buttonY + 2 * buttonInter, checkboxWidth, checkboxHeight, 'Fullscreen');
         fullScreenCheckbox.onClick = () => {
-            if(fullScreenCheckbox.isChecked){
+            if (fullScreenCheckbox.isChecked) {
                 myutil.exitFullscreen();
                 p5.resizeCanvas(1280, 720);
                 CanvasSize.setSize(1280, 720);
                 this.controller.reset(p5);
-            }
-            else{
+            } else {
                 let screenWidth = window.screen.width;
                 let screenHeight = window.screen.height;
                 myutil.enterFullscreen();
@@ -53,7 +50,7 @@
         this.buttons.push(englishButton, chineseButton, fullScreenCheckbox);
     }
 
-    reset(p5){
+    reset(p5) {
 
     }
 
Index: docs/src/model/Play.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {CanvasSize} from \"../CanvasSize.js\";\r\nimport {myutil} from \"../../lib/myutil.js\";\r\nimport {Button} from \"../items/Button.js\";\r\nimport {stateCode, stageGroup} from \"./GameState.js\";\r\nimport {BoardCells} from \"./BoardCells.js\";\r\nimport {InfoBox} from \"./InfoBox.js\";\r\nimport {PlantActive} from \"../items/PlantActive.js\";\r\nimport {baseType, enemyTypes, itemTypes, plantTypes, terrainTypes} from \"../items/ItemTypes.js\";\r\nimport {FloatingWindow} from \"./FloatingWindow.js\";\r\nimport {Screen} from \"./Screen.js\";\r\nimport {plantEnemyInteractions} from \"../items/PlantEnemyInter.js\";\r\nimport {Inventory} from \"./Inventory.js\";\r\nimport {Bandit} from \"../items/Bandit.js\";\r\nimport {Tornado} from \"../items/Tornado.js\";\r\nimport {VolcanicBomb} from \"../items/Volcano.js\";\r\nimport {Earthquake} from \"../items/Earthquake.js\";\r\nimport {Blizzard} from \"../items/Blizzard.js\";\r\nimport {SlideAnimation} from \"../items/SlideAnimation.js\";\r\nimport {TsunamiAnimation} from \"../items/TsunamiAnimation.js\";\r\n\r\nexport class PlayBoard extends Screen {\r\n    constructor(gameState) {\r\n        super(gameState);\r\n        this.stageGroup = stageGroup.NO_STAGE;\r\n        this.stageNumbering = \"0-0\";\r\n        this.canvasWidth = CanvasSize.getSize()[0];\r\n        this.canvasHeight = CanvasSize.getSize()[1];\r\n\r\n        // transformation parameters\r\n        this.Sx = 0.5;\r\n        this.Sy = 0.5;\r\n        this.rot = Math.PI / 6;\r\n        this.span = 2 * Math.PI / 3;\r\n        this.Hy = 1;\r\n\r\n        // grid parameters\r\n        this.gridSize = 8;\r\n        this.cellWidth = myutil.relative2absolute(1 / 16, 1 / 9)[0];\r\n        this.cellHeight = myutil.relative2absolute(1 / 16, 1 / 9)[1];\r\n\r\n        // store all movable objects including enemies\r\n        // objects in this array MUST have boolean fields hasMoved and isMoving!!!!!\r\n        this.movables = [];\r\n\r\n        // board objects array and information box\r\n        this.boardObjects = new BoardCells(this.gridSize);\r\n        this.selectedCell = [];\r\n        this.infoBox = new InfoBox(this);\r\n\r\n        // to store the items at the start of each stage,\r\n        // so when you quit we can reset inventory\r\n        this.tmpInventoryItems = new Map();\r\n\r\n        // turn counter\r\n        this.turn = 1;\r\n        this.maxTurn = 10;\r\n        this.endTurn = false;\r\n        // can place this number of plants every turn\r\n        this.actionPoints = 3;\r\n        this.maxActionPoints = 3;\r\n        this.hasActionPoints = true;\r\n\r\n        // to implement plant active skills.\r\n        // I have a strong feeling that we need refactoring\r\n        this.awaitCell = false;\r\n\r\n        this.ecoDisplay = true;\r\n\r\n        this.isGameOver = false;\r\n\r\n        this.skip = false;\r\n\r\n        // set cursor style when dragging item\r\n        this.shadowPlant = null;\r\n\r\n        // save last state\r\n        this.undoStack = [];\r\n\r\n        this.interactives = Array.from({length: 5},\r\n            () => Array.from({length: 5}, () => null));\r\n\r\n        this.row = 0;\r\n        this.col = 0;\r\n        this.x = 640;\r\n        this.y = 360;\r\n    }\r\n\r\n    /* public methods */\r\n\r\n    setup(p5) {\r\n        // action listeners\r\n        this.setupActionListeners(p5);\r\n\r\n        // setup stage terrain\r\n        this.setStageTerrain(p5);\r\n\r\n        // initialized all fw\r\n        this.initAllFloatingWindows(p5);\r\n    }\r\n\r\n    setupActionListeners(p5){\r\n        // escape button\r\n        let [escX, escY] = myutil.relative2absolute(0.01, 0.01);\r\n        let [escWidth, escHeight] = myutil.relative2absolute(0.09, 0.07);\r\n        let escapeButton = new Button(escX, escY, escWidth, escHeight, \"Escape\");\r\n        escapeButton.onClick = () => {\r\n            this.gameState.setState(stateCode.STANDBY);\r\n        };\r\n\r\n        // undo\r\n        let [undoX, undoY] = myutil.relative2absolute(0.1, 0.01);\r\n        let [undoWidth, undoHeight] = myutil.relative2absolute(0.09, 0.07);\r\n        let undoButton = new Button(undoX, undoY, undoWidth, undoHeight, \"Undo\");\r\n        undoButton.onClick = () => {\r\n            this.undo(p5);\r\n        }\r\n\r\n        // turn button\r\n        let [turnWidth, turnHeight] = myutil.relative2absolute(5 / 32, 0.07);\r\n        let [turnX, turnY] = myutil.relative2absolute(0.5, 0.01);\r\n        let turnButton = new Button(turnX - turnWidth / 2, turnY, turnWidth, turnHeight, this.getTurnButtonText());\r\n        turnButton.onClick = () => {\r\n            this.movables.sort((a, b) => {\r\n                if (a.enemyType !== undefined && b.enemyType !== undefined) {\r\n                    return a.enemyType - b.enemyType;\r\n                }\r\n                if (a.enemyType !== undefined) return -1;\r\n                if (b.enemyType !== undefined) return 1;\r\n                return 0;\r\n            });\r\n            // set movable status\r\n            for (let movable of this.movables) {\r\n                movable.hasMoved = false;\r\n            }\r\n            // when game is not cleared, remember to deal with end turn stuff\r\n            if (this.turn < this.maxTurn + 1) {\r\n                this.endTurn = true;\r\n            }\r\n            // once player unable to click, controller will loop movables to check if there are anything has not moved\r\n            this.gameState.setPlayerCanClick(false);\r\n        }\r\n\r\n        this.buttons.push(escapeButton, turnButton, undoButton);\r\n\r\n        // a keyboard shortcut to activate plant skill\r\n        window.addEventListener(\"keyup\", (event) => {\r\n            // active skill\r\n            if (event.key === \"e\" && this.infoBox.activateButton !== null) {\r\n                this.infoBox.activateButton._onClick(p5);\r\n            }\r\n            // toggle display ecosystem\r\n            if (event.key === \"e\" && this.infoBox.displayButton !== null) {\r\n                this.infoBox.displayButton._onClick(p5);\r\n            }\r\n            // turn button\r\n            if (event.key === \" \" && this.gameState.playerCanClick && this.floatingWindow === null) {\r\n                this.buttons.find(b => b.text.startsWith(\"turn\"))._onClick();\r\n            }\r\n            // to dev team: quick skip current stage\r\n            if (event.key === \"c\" && !this.skip) {\r\n                this.skip = true;\r\n                this.stageClearSettings(p5);\r\n                this.gameState.setState(stateCode.FINISH);\r\n            }\r\n            // info box arrows\r\n            if (event.key === \"a\" && this.selectedCell.length !== 0) {\r\n                this.infoBox.clickLeftArrow(p5);\r\n            }\r\n            if (event.key === \"ArrowLeft\" && this.selectedCell.length !== 0) {\r\n                this.infoBox.clickLeftArrow(p5);\r\n            }\r\n            if (event.key === \"d\" && this.selectedCell.length !== 0) {\r\n                this.infoBox.clickRightArrow(p5);\r\n            }\r\n            if (event.key === \"ArrowRight\" && this.selectedCell.length !== 0) {\r\n                this.infoBox.clickRightArrow(p5);\r\n            }\r\n        });\r\n    }\r\n\r\n    handleScroll(p5, event) {\r\n        if (p5.mouseX >= this.gameState.inventory.inventoryX\r\n            && p5.mouseX <= this.gameState.inventory.inventoryX + this.gameState.inventory.inventoryWidth\r\n            && p5.mouseY >= this.gameState.inventory.inventoryY\r\n            && p5.mouseY <= this.gameState.inventory.inventoryY + this.gameState.inventory.inventoryHeight) {\r\n            this.gameState.inventory.handleScroll(event);\r\n        }\r\n    }\r\n\r\n    handleClick(p5) {\r\n        if (this.handleFloatingWindow()) {\r\n            return;\r\n        }\r\n\r\n        this.handleActiveSkills(p5);\r\n\r\n        // click any button\r\n        for (let button of this.buttons) {\r\n            if (button.mouseClick(p5) && button === this.infoBox.activateButton) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        // clicked info box arrows when info box exists\r\n        if (this.infoBox.handleClickArrow(p5, this)) {\r\n            return;\r\n        }\r\n\r\n        // inventory item and planting\r\n        this.handlePlanting(p5);\r\n\r\n        // click any grid cell to display info box\r\n        this.clickedCell(p5);\r\n    }\r\n\r\n    stringify() {\r\n        let status = {\r\n            boardObjects: this.boardObjects.stringify(),\r\n            inventory: this.gameState.inventory.stringify(),\r\n            movables: JSON.stringify(this.movables.map(movable => movable.stringify())),\r\n            actionPoints: this.actionPoints,\r\n            maxActionPoints: this.maxActionPoints,\r\n        }\r\n        this.undoStack.push(JSON.stringify(status));\r\n        return status;\r\n    }\r\n\r\n    undo(p5) {\r\n        if (this.undoStack.length === 0) return;\r\n\r\n        let status = JSON.parse(this.undoStack.pop());\r\n\r\n        // reset board\r\n        this.boardObjects = BoardCells.parse(status.boardObjects, p5, this);\r\n        // reset action points\r\n        this.maxActionPoints = status.maxActionPoints;\r\n        this.actionPoints = status.actionPoints;\r\n        // reset plant skills\r\n        this.reevaluatePlantSkills();\r\n        // reset ecosystem\r\n        this.boardObjects.setEcosystem();\r\n        // reset inventory\r\n        this.gameState.inventory = Inventory.parse(status.inventory, p5);\r\n\r\n        // reset movables, need to put movable with cell to the correct cell\r\n        this.movables = JSON.parse(status.movables).map(json => {\r\n            const movable = JSON.parse(json);\r\n            switch (movable.enemyType) {\r\n                case enemyTypes.BANDIT:\r\n                    return Bandit.parse(json, p5, this);\r\n                case enemyTypes.TORNADO:\r\n                    return Tornado.parse(json, p5, this);\r\n                case enemyTypes.BOMB:\r\n                    return VolcanicBomb.parse(json, p5, this);\r\n                case enemyTypes.SLIDE:\r\n                    return SlideAnimation.parse(json, p5, this);\r\n                case enemyTypes.EARTHQUAKE:\r\n                    return Earthquake.parse(json, p5, this);\r\n                case enemyTypes.BLIZZARD:\r\n                    return Blizzard.parse(json, p5, this);\r\n                case enemyTypes.TSUNAMI:\r\n                    return TsunamiAnimation.parse(json, p5, this);\r\n                default:\r\n                    console.warn(\"Unknown enemy type\", movable.enemyType);\r\n                    return null;\r\n            }\r\n        }).filter(Boolean);\r\n        for (let movable of this.movables) {\r\n            if (movable.cell) {\r\n                movable.cell.enemy = movable;\r\n            }\r\n        }\r\n    }\r\n\r\n    saveGame(){\r\n        let status = this.stringify();\r\n        status.stageGroup = this.stageGroup;\r\n        status.stageNumbering = Number(this.stageNumbering.charAt(2));\r\n        status.turn = this.turn;\r\n        status.tmpInventoryItems = Array.from(this.tmpInventoryItems.entries());\r\n        if(this.snowfields !== undefined){\r\n            status.snowfields = JSON.stringify(this.snowfields);\r\n        }\r\n        if(this.fertilized !== undefined){\r\n            status.fertilized = JSON.stringify(this.fertilized);\r\n        }\r\n        return JSON.stringify(status);\r\n    }\r\n\r\n    static loadGame(p5, gameState, status){\r\n        let statusObject = JSON.parse(status);\r\n        let playBoard = new gameState.gsf.stageClasses[statusObject.stageGroup][statusObject.stageNumbering - 1](gameState);\r\n        playBoard.undoStack.push(status);\r\n        playBoard.undo(p5);\r\n        playBoard.turn = statusObject.turn;\r\n        playBoard.tmpInventoryItems = new Map(statusObject.tmpInventoryItems);\r\n        if(playBoard.snowfields) playBoard.snowfields = JSON.parse(statusObject.snowfields);\r\n        if(playBoard.fertilized) playBoard.fertilized = JSON.parse(statusObject.fertilized);\r\n        playBoard.setupActionListeners(p5);\r\n        playBoard.initAllFloatingWindows(p5);\r\n        return playBoard;\r\n    }\r\n\r\n    draw(p5) {\r\n        p5.background(180);\r\n\r\n        // set cursor style\r\n        if (this.gameState.inventory.selectedItem !== null) {\r\n            p5.cursor('grab');\r\n        } else if (this.awaitCell) {\r\n            p5.cursor('pointer');\r\n        } else {\r\n            p5.cursor(p5.ARROW);\r\n        }\r\n\r\n        // stage number text\r\n        let [stageNumberingX, stageNumberingY] = myutil.relative2absolute(0.38, 0.04);\r\n        p5.textSize(20);\r\n        p5.fill('red');\r\n        p5.noStroke();\r\n        p5.textAlign(p5.LEFT, p5.TOP);\r\n        p5.text(this.stageNumbering, stageNumberingX, stageNumberingY);\r\n\r\n        // draw stage grid\r\n        this.drawGrid(p5);\r\n\r\n        // left bottom corner info box\r\n        if (this.selectedCell.length !== 0) {\r\n            this.infoBox.draw(p5, this);\r\n        }\r\n\r\n        // draw plants according to board objects\r\n        this.drawAllPlants(p5);\r\n\r\n        // tornado arrows first\r\n        for (let movable of this.movables) {\r\n            if (!movable.isMoving && movable.type === itemTypes.ENEMY && movable.enemyType === enemyTypes.TORNADO) {\r\n                let direction = movable.direction;\r\n                let x = movable.x;\r\n                let y = movable.y;\r\n                let angle;\r\n                if (direction[0] === 0 && direction[1] === -1) {\r\n                    angle = p5.radians(330); // Up-right\r\n                } else if (direction[0] === 0 && direction[1] === 1) {\r\n                    angle = p5.radians(150); // Down-left\r\n                } else if (direction[0] === -1 && direction[1] === 0) {\r\n                    angle = p5.radians(210); // Up-left\r\n                } else if (direction[0] === 1 && direction[1] === 0) {\r\n                    angle = p5.radians(30); // Down-right\r\n                }\r\n                let offset = 10;\r\n                let dx = offset * Math.cos(angle);\r\n                let dy = offset * Math.sin(angle);\r\n                p5.push();\r\n                p5.translate(x + dx, y + dy);\r\n                p5.rotate(angle + p5.HALF_PI);\r\n                p5.imageMode(p5.CENTER);\r\n                p5.image(p5.images.get(\"alertArrow\"), 0, 0, 30, 30);\r\n                p5.pop();\r\n            }\r\n        }\r\n        // draw all movables according to this.movables\r\n        for (let movable of this.movables) {\r\n            movable.draw(p5);\r\n        }\r\n        // health bar last\r\n        for (let movable of this.movables) {\r\n            if (movable.health !== undefined) {\r\n                myutil.drawHealthBar(p5, movable, movable.x - 20, movable.y - 50, 40, 5);\r\n            }\r\n        }\r\n\r\n\r\n        // draw inventory\r\n        this.gameState.inventory.draw(p5, this.canvasWidth, this.canvasHeight);\r\n\r\n        // draw action points\r\n        myutil.drawActionPoints(p5, this);\r\n\r\n        // all buttons\r\n        // to cascade activate button above info box, place this loop after info box\r\n        for (let button of this.buttons) {\r\n            if (!(this.turn === this.maxTurn + 1 && button.text.startsWith(\"turn\"))) {\r\n                button.draw(p5);\r\n            }\r\n        }\r\n\r\n        // if game over, set player can click to stop movables updating\r\n        if (this.isGameOver && !this.gameState.playerCanClick) {\r\n            this.gameState.setPlayerCanClick(true);\r\n        }\r\n\r\n        this.drawFloatingWindow(p5);\r\n\r\n        // draw shadow plant\r\n        if (this.shadowPlant !== null) {\r\n            let imgSize = myutil.relative2absolute(1 / 32, 0)[0];\r\n            p5.push();\r\n            p5.tint(255, 180);\r\n            p5.image(this.shadowPlant.img, p5.mouseX - imgSize / 2, p5.mouseY - 3 * imgSize / 4, imgSize, imgSize);\r\n            p5.pop();\r\n        }\r\n\r\n        p5.circle(this.x, this.y, 10);\r\n    }\r\n\r\n    // ----------------------------------- //\r\n    // ----------------------------------- //\r\n    // ----------------------------------- //\r\n    // ----------------------------------- //\r\n    // below can be treated as black boxes //\r\n    // ----------------------------------- //\r\n    // ----------------------------------- //\r\n    // ----------------------------------- //\r\n    // ----------------------------------- //\r\n\r\n    drawGrid(p5) {\r\n        p5.stroke(0);\r\n        p5.strokeWeight(2);\r\n\r\n        for (let i = 0; i < this.gridSize; i++) {\r\n            for (let j = 0; j < this.gridSize; j++) {\r\n                this.boardObjects.getCell(i, j).drawTerrain(p5, this);\r\n            }\r\n        }\r\n        if(this.boardObjects.getCell(2, 2).terrain.terrainType === terrainTypes.VOLCANO) {\r\n            let [x1, y1] = myutil.cellIndex2Pos(p5, this, 2, 2, p5.CORNERS);\r\n            p5.image(p5.images.get(\"VolcanoLayer\"), x1 - this.cellWidth * 3 / 2, y1 - this.cellHeight * 3 + this.cellHeight/2 + 1, this.cellWidth * 3, this.cellHeight * 3);\r\n        }\r\n\r\n\r\n        for(let i = 0; i < this.gridSize; i++) {\r\n            for (let j = 0; j < this.gridSize; j++) {\r\n                if(this.boardObjects.getCell(i, j).terrain.terrainType === terrainTypes.MOUNTAIN){\r\n                    let [x, y] = myutil.cellIndex2Pos(p5, this, i, j, p5.CORNERS);\r\n                    p5.image(p5.images.get(\"MountainLayer\"), x-this.cellWidth/2, y - this.cellHeight + this.cellHeight/2, this.cellWidth, this.cellHeight);\r\n                }\r\n            }\r\n        }\r\n        // if skill is activated and awaiting target, set highlight on\r\n        if (this.awaitCell) {\r\n            for (let i = 0; i < this.boardObjects.size; i++) {\r\n                for (let j = 0; j < this.boardObjects.size; j++) {\r\n                    if (PlantActive.activeRange1(i, j, this.selectedCell[0], this.selectedCell[1])) {\r\n                        let [x1, y1, x2, y2, x3, y3, x4, y4] = myutil.cellIndex2Pos(p5, this, i, j, p5.CORNERS);\r\n                        p5.stroke('rgb(255,238,0)');\r\n                        p5.strokeWeight(2);\r\n                        p5.quad(x1, y1, x2, y2, x3, y3, x4, y4);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // highlight the cell mouse hovering on\r\n        for (let i = 0; i < this.gridSize; i++) {\r\n            for (let j = 0; j < this.gridSize; j++) {\r\n                let [x1, y1, x2, y2, x3, y3, x4, y4] = myutil.cellIndex2Pos(p5, this, i, j, p5.CORNERS);\r\n                if (myutil.isCursorInQuad(p5.mouseX, p5.mouseY, x1, y1, x2, y2, x3, y3, x4, y4)) {\r\n                    p5.stroke('rgb(255,238,0)');\r\n                    p5.strokeWeight(2);\r\n                    p5.noFill();\r\n                    p5.quad(x1, y1, x2, y2, x3, y3, x4, y4);\r\n                }\r\n            }\r\n        }\r\n        p5.strokeWeight(0);\r\n    }\r\n\r\n    drawAllPlants(p5) {\r\n        for (let i = 0; i < this.gridSize; i++) {\r\n            for (let j = 0; j < this.gridSize; j++) {\r\n                let cell = this.boardObjects.getCell(i, j);\r\n                if (cell.plant !== null) {\r\n                    let [avgX, avgY] = myutil.cellIndex2Pos(p5, this, i, j, p5.CENTER);\r\n                    let imgSize = myutil.relative2absolute(1 / 32, 0)[0];\r\n                    p5.image(cell.plant.img, avgX - imgSize / 2, avgY - 3 * imgSize / 4, imgSize, imgSize);\r\n                    myutil.drawHealthBar(p5, cell.plant, avgX - 21, avgY - 42, 40, 5);\r\n                }\r\n                if (cell.seed !== null) {\r\n                    let [avgX, avgY] = myutil.cellIndex2Pos(p5, this, i, j, p5.CENTER);\r\n                    let imgSize = myutil.relative2absolute(1 / 32, 0)[0];\r\n                    p5.image(cell.seed.img, avgX - imgSize / 2, avgY - 3 * imgSize / 4, imgSize, imgSize);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // set the clicked cell to draw info box\r\n    clickedCell(p5) {\r\n        let index = myutil.pos2CellIndex(this, p5.mouseX, p5.mouseY);\r\n        if (index[0] === -1) {\r\n            this.selectedCell = [];\r\n        } else {\r\n            this.selectedCell = [index[0], index[1]];\r\n            // a shortcut to direct to plant active skill page\r\n            let cell = this.boardObjects.getCell(index[0], index[1]);\r\n            if (cell.plant !== null && cell.plant.hasActive) {\r\n                this.infoBox.setStatus(p5, 'a');\r\n            }\r\n        }\r\n    }\r\n\r\n    // when floating window is on, click anywhere to disable it.\r\n    handleFloatingWindow() {\r\n        if (this.floatingWindow !== null) {\r\n            // game over\r\n            if (!this.allFloatingWindows.has(\"001\")) {\r\n                this.gameState.setState(stateCode.STANDBY);\r\n                return true;\r\n            }\r\n            // game clear\r\n            if (!this.allFloatingWindows.has(\"000\")) {\r\n                this.gameState.setState(stateCode.FINISH);\r\n                return true;\r\n            }\r\n            // common floating windows\r\n            if (!this.floatingWindow.isFading) {\r\n                this.floatingWindow.isFading = true;\r\n            }\r\n            if (!this.floatingWindow.playerCanClick) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    handleActiveSkills(p5) {\r\n        // when activate button is clicked, system awaits a cell input\r\n        if (this.awaitCell) {\r\n            let index = myutil.pos2CellIndex(this, p5.mouseX, p5.mouseY);\r\n            if (index[0] === -1) {\r\n                this.floatingWindow = FloatingWindow.copyOf(this.allFloatingWindows.get(\"050\"));\r\n            } else {\r\n                // this branch represents skill has been activated successfully\r\n                this.stringify();\r\n                let spellCaster = this.boardObjects.getCell(this.selectedCell[0], this.selectedCell[1]);\r\n                let target = this.boardObjects.getCell(index[0], index[1]);\r\n                if (spellCaster.plant.plantType === plantTypes.TREE) {\r\n                    PlantActive.rechargeHP(this, spellCaster, target, 1);\r\n                } else if (spellCaster.plant.plantType === plantTypes.ORCHID) {\r\n                    PlantActive.sendAnimalFriends(this, spellCaster, target);\r\n                }\r\n            }\r\n            this.awaitCell = false;\r\n        }\r\n\r\n        // there might be other types of skill that does not wait one cell,\r\n        // so separate this chunk of code for easier later refactor.\r\n    }\r\n\r\n    handlePlanting(p5) {\r\n        let index = myutil.pos2CellIndex(this, p5.mouseX, p5.mouseY);\r\n        // clicked an item from inventory, then clicked a cell:\r\n        if (this.gameState.inventory.selectedItem !== null && index[0] !== -1) {\r\n            if (this.actionPoints > 0) {\r\n                this.stringify();\r\n                if (this.boardObjects.plantCell(p5, this, index[0], index[1], this.gameState.inventory.createItem(p5, this.gameState.inventory.selectedItem))) {\r\n                    console.log(`Placed ${this.gameState.inventory.selectedItem} at row ${index[0]}, col ${index[1]}`);\r\n                    this.shadowPlant = null;\r\n                    if (this.hasActionPoints) {\r\n                        this.actionPoints--;\r\n                    }\r\n                    // set plant's skill\r\n                    this.reevaluatePlantSkills();\r\n\r\n                    // remove item from inventory\r\n                    this.gameState.inventory.itemDecrement();\r\n\r\n                    // set countdown for seed\r\n                    this.setSeedCountdown(index[0], index[1]);\r\n\r\n                    // if kiku is planted, increase upper limit of action points immediately\r\n                    if(this.boardObjects.getCell(index[0], index[1])?.plant?.plantType === plantTypes.KIKU) {\r\n                        this.maxActionPoints++;\r\n                        this.actionPoints++;\r\n                    }\r\n\r\n                    return;\r\n                }\r\n            } else {\r\n                if (this.hasActionPoints && this.actionPoints === 0) {\r\n                    this.floatingWindow = FloatingWindow.copyOf(this.allFloatingWindows.get(\"002\"));\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        // clicked item from inventory or clicked somewhere else:\r\n        // handle inventory clicks later to prevent unintentional issues\r\n        this.gameState.inventory.handleClick(p5);\r\n        if (this.gameState.inventory.selectedItem !== null && index[0] === -1) {\r\n            this.shadowPlant = this.gameState.inventory.createItem(p5, this.gameState.inventory.selectedItem);\r\n        } else {\r\n            this.shadowPlant = null;\r\n        }\r\n    }\r\n\r\n    setSeedCountdown(x, y){\r\n        // used in stage 5\r\n    }\r\n\r\n    // miscellaneous end turn settings\r\n    endTurnActivity(p5) {\r\n        // clear undo stack\r\n        this.undoStack = [];\r\n\r\n        // remove dead plants and reset plant skill\r\n        let cells = this.boardObjects.getAllCellsWithPlant();\r\n        for (let cell of cells) {\r\n            // a safe-lock to remove all dead plants\r\n            if (cell.plant.status === false) {\r\n                this.boardObjects.removePlant(cell.x, cell.y);\r\n            }\r\n            // reset active skill status\r\n            if (cell.plant.hasActive) {\r\n                cell.plant.useLeft = cell.plant.maxUse;\r\n            }\r\n        }\r\n\r\n        // update seed status\r\n        let cellsWithSeed = this.boardObjects.getAllCellsWithSeed();\r\n        for (let cws of cellsWithSeed) {\r\n            let grown = cws.seed.grow(p5);\r\n            if (grown.type === itemTypes.SEED) {\r\n                cws.seed = grown;\r\n            } else if (grown.type === itemTypes.PLANT) {\r\n                cws.removeSeed();\r\n                cws.plant = grown;\r\n            }\r\n        }\r\n\r\n        // reevaluate plants' skills, after seeds have grown up\r\n        this.reevaluatePlantSkills();\r\n\r\n        // also, reconstruct ecosystem\r\n        this.boardObjects.setEcosystem();\r\n\r\n        // set turn and counter\r\n        this.turn++;\r\n        this.buttons.find(button => button.text.startsWith(\"turn\")).text = this.getTurnButtonText();\r\n        if (this.turn === this.maxTurn + 1) {\r\n            this.stageClearSettings(p5);\r\n            return;\r\n        } else {\r\n            this.endTurn = false;\r\n        }\r\n\r\n        // set next turn enemies and new inventory items\r\n        this.nextTurnItems(p5);\r\n\r\n        // count the total number of kiku to determine max action points\r\n        let count = 0;\r\n        for (let cwp of this.boardObjects.getAllCellsWithPlant()) {\r\n            if(cwp?.plant.plantType === plantTypes.KIKU) count++;\r\n        }\r\n        this.maxActionPoints = 3 + count;\r\n        // reset action points\r\n        this.actionPoints = this.maxActionPoints;\r\n\r\n        // set action listener active\r\n        this.gameState.setPlayerCanClick(true);\r\n    }\r\n\r\n    stageClearSettings(p5) {\r\n        // when a stage is cleared:    \r\n        // 1. store all living plants, this comes after seeds have grown\r\n        let cellsWithPlant = this.boardObjects.getAllCellsWithPlant();\r\n        for (let cws of cellsWithPlant) {\r\n            this.gameState.inventory.pushItem2Inventory(p5, cws.plant.name, 1);\r\n        }\r\n        // 2. remove all seeds and bamboo from inventory\r\n        this.gameState.inventory.removeAllSeedsAndBamboo();\r\n        // 3. set current stage cleared\r\n        this.gameState.setStageCleared(this);\r\n        // 4. reset action listener\r\n        this.gameState.setPlayerCanClick(true);\r\n    }\r\n\r\n    setAndResolveCounter(p5) {\r\n        let cells = this.boardObjects.getAllCellsWithPlant();\r\n\r\n        // increment earth counters, decrement cold counters.\r\n        for (let cwp of cells) {\r\n            if (cwp.plant.earthCounter === undefined) {\r\n                cwp.plant.earthCounter = 1;\r\n            } else {\r\n                cwp.plant.earthCounter++;\r\n            }\r\n            if (cwp.terrain.terrainType === terrainTypes.SNOWFIELD) {\r\n                if (cwp.plant.coldCounter === undefined) {\r\n                    cwp.plant.coldCounter = 2;\r\n                } else {\r\n                    cwp.plant.coldCounter--;\r\n                    if (cwp.plant.coldCounter <= 0) {\r\n                        plantEnemyInteractions.findPlantAndDelete(this, cwp.plant);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!this.hasBamboo) {\r\n            // if a tree has a counter=10, insert bamboo into inventory.\r\n            for (let cwp of cells) {\r\n                if (cwp.plant.earthCounter !== undefined && cwp.plant.earthCounter >= 10 && baseType(cwp.plant) === plantTypes.TREE) {\r\n                    this.modifyBoard(p5, \"bamboo\");\r\n                    this.hasBamboo = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // when a new plant is placed or removed,\r\n    // we need to verify all plant's skill status.\r\n    reevaluatePlantSkills() {\r\n        let cells = this.boardObjects.getAllCellsWithPlant();\r\n        for (let cell of cells) {\r\n            cell.plant.reevaluateSkills(this, cell);\r\n        }\r\n    }\r\n\r\n    // this does not activate skill immediately, but go to awaiting status\r\n    activatePlantSkill(p5) {\r\n        let spellCaster = this.boardObjects.getCell(this.selectedCell[0], this.selectedCell[1]);\r\n        if (spellCaster.plant.plantType === plantTypes.TREE || spellCaster.plant.plantType === plantTypes.ORCHID) {\r\n            this.awaitCell = true;\r\n        }\r\n    }\r\n\r\n    nextTurnItems(p5) {\r\n        console.error(\"nextTurnEnemies is not overridden!\");\r\n    }\r\n\r\n    // set stage inventory at entering, called by controller\r\n    setStageInventory(p5) {\r\n        console.error(\"setStageInventory is not overridden!\");\r\n    }\r\n\r\n    // set stage terrain, called when the stage is loaded or reset\r\n    setStageTerrain(p5) {\r\n        console.error(\"setStageTerrain is not overridden!\");\r\n    }\r\n\r\n    getTurnButtonText() {\r\n        return `turn ${this.turn} in ${this.maxTurn}`;\r\n    }\r\n\r\n    setupInteractive(){}\r\n\r\n    moveSelection(){}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/model/Play.js b/docs/src/model/Play.js
--- a/docs/src/model/Play.js	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ b/docs/src/model/Play.js	(date 1744215531307)
@@ -98,7 +98,7 @@
         this.initAllFloatingWindows(p5);
     }
 
-    setupActionListeners(p5){
+    setupActionListeners(p5) {
         // escape button
         let [escX, escY] = myutil.relative2absolute(0.01, 0.01);
         let [escWidth, escHeight] = myutil.relative2absolute(0.09, 0.07);
@@ -178,15 +178,6 @@
         });
     }
 
-    handleScroll(p5, event) {
-        if (p5.mouseX >= this.gameState.inventory.inventoryX
-            && p5.mouseX <= this.gameState.inventory.inventoryX + this.gameState.inventory.inventoryWidth
-            && p5.mouseY >= this.gameState.inventory.inventoryY
-            && p5.mouseY <= this.gameState.inventory.inventoryY + this.gameState.inventory.inventoryHeight) {
-            this.gameState.inventory.handleScroll(event);
-        }
-    }
-
     handleClick(p5) {
         if (this.handleFloatingWindow()) {
             return;
@@ -272,30 +263,30 @@
         }
     }
 
-    saveGame(){
+    saveGame() {
         let status = this.stringify();
         status.stageGroup = this.stageGroup;
         status.stageNumbering = Number(this.stageNumbering.charAt(2));
         status.turn = this.turn;
         status.tmpInventoryItems = Array.from(this.tmpInventoryItems.entries());
-        if(this.snowfields !== undefined){
+        if (this.snowfields !== undefined) {
             status.snowfields = JSON.stringify(this.snowfields);
         }
-        if(this.fertilized !== undefined){
+        if (this.fertilized !== undefined) {
             status.fertilized = JSON.stringify(this.fertilized);
         }
         return JSON.stringify(status);
     }
 
-    static loadGame(p5, gameState, status){
+    static loadGame(p5, gameState, status) {
         let statusObject = JSON.parse(status);
         let playBoard = new gameState.gsf.stageClasses[statusObject.stageGroup][statusObject.stageNumbering - 1](gameState);
         playBoard.undoStack.push(status);
         playBoard.undo(p5);
         playBoard.turn = statusObject.turn;
         playBoard.tmpInventoryItems = new Map(statusObject.tmpInventoryItems);
-        if(playBoard.snowfields) playBoard.snowfields = JSON.parse(statusObject.snowfields);
-        if(playBoard.fertilized) playBoard.fertilized = JSON.parse(statusObject.fertilized);
+        if (playBoard.snowfields) playBoard.snowfields = JSON.parse(statusObject.snowfields);
+        if (playBoard.fertilized) playBoard.fertilized = JSON.parse(statusObject.fertilized);
         playBoard.setupActionListeners(p5);
         playBoard.initAllFloatingWindows(p5);
         return playBoard;
@@ -423,9 +414,9 @@
                 this.boardObjects.getCell(i, j).drawTerrain(p5, this);
             }
         }
-        if(this.boardObjects.getCell(2, 2).terrain.terrainType === terrainTypes.VOLCANO) {
+        if (this.boardObjects.getCell(2, 2).terrain.terrainType === terrainTypes.VOLCANO) {
             let [x1, y1] = myutil.cellIndex2Pos(p5, this, 2, 2, p5.CORNERS);
-            p5.image(p5.images.get("VolcanoLayer"), x1 - this.cellWidth * 3 / 2, y1 - this.cellHeight * 3 + this.cellHeight/2 + 1, this.cellWidth * 3, this.cellHeight * 3);
+            p5.image(p5.images.get("VolcanoLayer"), x1 - this.cellWidth * 3 / 2, y1 - this.cellHeight * 3 + this.cellHeight / 2 + 1, this.cellWidth * 3, this.cellHeight * 3);
         }
 
 
@@ -570,7 +561,7 @@
                     this.setSeedCountdown(index[0], index[1]);
 
                     // if kiku is planted, increase upper limit of action points immediately
-                    if(this.boardObjects.getCell(index[0], index[1])?.plant?.plantType === plantTypes.KIKU) {
+                    if (this.boardObjects.getCell(index[0], index[1])?.plant?.plantType === plantTypes.KIKU) {
                         this.maxActionPoints++;
                         this.actionPoints++;
                     }
@@ -595,7 +586,7 @@
         }
     }
 
-    setSeedCountdown(x, y){
+    setSeedCountdown(x, y) {
         // used in stage 5
     }
 
@@ -651,7 +642,7 @@
         // count the total number of kiku to determine max action points
         let count = 0;
         for (let cwp of this.boardObjects.getAllCellsWithPlant()) {
-            if(cwp?.plant.plantType === plantTypes.KIKU) count++;
+            if (cwp?.plant.plantType === plantTypes.KIKU) count++;
         }
         this.maxActionPoints = 3 + count;
         // reset action points
Index: docs/src/model/GameMap.js
===================================================================
diff --git a/docs/src/model/GameMap.js b/docs/src/model/GameMap.js
deleted file mode 100644
--- a/docs/src/model/GameMap.js	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ /dev/null	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
@@ -1,62 +0,0 @@
-import {myutil} from "../../lib/myutil.js";
-import {Button} from "../items/Button.js";
-import {GameSave} from "./GameSave.js";
-import {stageGroup, stateCode} from "./GameState.js";
-import {Icon} from "../items/Icon.js";
-import {CanvasSize} from "../CanvasSize.js";
-
-export class GameMap {
-    constructor(gameState) {
-        this.gameState = gameState;
-        this.canvasWidth = CanvasSize.getSize()[0];
-        this.canvasHeight = CanvasSize.getSize()[1];
-        this.buttons = [];
-        this.icons = [];
-    }
-
-    setup(p5) {
-
-        let [buttonWidth, buttonHeight] = myutil.relative2absolute(0.09, 0.16);
-        let [buttonX, buttonY] = myutil.relative2absolute(0.35, 0.25);
-        let buttonInter = myutil.relative2absolute(0.2, 0.2)[1];
-
-        let level1Icon = new Icon(p5, buttonX, buttonY, buttonWidth, buttonHeight);
-        console.log("level1Icon", level1Icon);
-        level1Icon.onClick = () => {
-            this.gameState.setState(stateCode.PLAY);
-            this.gameState.currentStageGroup = stageGroup.TORNADO;
-        }
-        this.icons.push(level1Icon);
-    }
-
-    handleClick(p5) {
-        for (let button of this.buttons) {
-            if (button.mouseClick(p5)) {
-                return;
-            }
-        }
-
-        for (let icon of this.icons) {
-            if (icon.mouseClick(p5)) {
-                return;
-            }
-        }
-    }
-
-    handleKey() {
-
-    }
-
-    draw(p5) {
-        p5.image(p5.images.get("GameMap"), 0, 0, this.canvasWidth, this.canvasHeight);
-        for (let button of this.buttons) {
-            button.draw(p5);
-        }
-
-        for (let icon of this.icons) {
-            icon.update();
-            icon.draw(p5);
-        }
-    }
-
-}
\ No newline at end of file
Index: docs/src/items/TsunamiAnimation.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {Enemy} from \"./Enemy.js\";\r\nimport {enemyTypes, plantTypes, terrainTypes} from \"./ItemTypes.js\";\r\nimport {PlayBoard} from \"../model/Play.js\";\r\nimport {plantEnemyInteractions} from \"./PlantEnemyInter.js\";\r\nimport {myutil} from \"../../lib/myutil.js\";\r\n\r\nexport class TsunamiAnimation extends Enemy {\r\n    constructor(p5, playBoard, startCol, startRow, range = 1, blockerLimit = 3) {\r\n        super(-1, -1);\r\n        this.name = \"Tsunami\";\r\n        this.enemyType = enemyTypes.TSUNAMI;\r\n        this.img = this.img = p5.images.get(`${this.name}`);\r\n\r\n        this.playBoard = playBoard;\r\n\r\n        this.startCol = startCol;\r\n        this.startRow = startRow;\r\n\r\n        // maximum range able to reach\r\n        this.range = Array.from({length: this.playBoard.gridSize}, () => range);\r\n\r\n        // 0 <= moved length[i] <= this.range[i]\r\n        this.movedLength = Array.from({length: this.playBoard.gridSize}, () => 0);\r\n\r\n        // when blocker[i] -> 0, decrease range[i] by 1\r\n        this.blockerLimit = blockerLimit;\r\n        this.blocker = Array.from({length: this.playBoard.gridSize}, () => this.blockerLimit);\r\n\r\n        // loop through this to end moving\r\n        this.isMovingArray = Array.from({length: this.playBoard.gridSize}, () => false);\r\n\r\n        this.isMoving = false;\r\n        this.hasMoved = true;\r\n\r\n        this.accumulate = 0;\r\n    }\r\n\r\n    static createNewTsunami(p5, playBoard, startCol, startRow, range) {\r\n        let tsunami = new TsunamiAnimation(p5, playBoard, startCol, startRow, range);\r\n        playBoard.movables.push(tsunami);\r\n    }\r\n\r\n    draw(p5) {\r\n        let imgSize = myutil.relative2absolute(1 / 40, 0)[0];\r\n        if (this.startCol !== -1) {\r\n            for (let i = 0; i < this.playBoard.gridSize; i++) {\r\n                for (let j = 0; j <= this.movedLength[i]; j++) {\r\n                    let [avgX, avgY] = myutil.cellIndex2Pos(p5, this.playBoard, i, this.startCol + j, p5.CENTER);\r\n                    p5.image(this.img, avgX - imgSize / 2, avgY - imgSize / 2, imgSize, imgSize);\r\n                }\r\n            }\r\n        } else {\r\n            for (let j = 0; j < this.playBoard.gridSize; j++) {\r\n                for (let i = 0; i <= this.movedLength[j]; i++) {\r\n                    let [avgX, avgY] = myutil.cellIndex2Pos(p5, this.playBoard, this.startRow + i, j, p5.CENTER);\r\n                    p5.image(this.img, avgX - imgSize / 2, avgY - imgSize / 2, imgSize, imgSize);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    checkIsMoving() {\r\n        for (let isMoving of this.isMovingArray) {\r\n            if (isMoving) return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    movements(p5, playBoard) {\r\n        if (!(playBoard instanceof PlayBoard)) {\r\n            console.error('movements of TsunamiAnimation has received invalid PlayBoard.');\r\n            return false;\r\n        }\r\n        if (this.hasMoved) {\r\n            return false;\r\n        }\r\n        if (this.isMoving) {\r\n            this.move(p5, playBoard);\r\n            return true;\r\n        }\r\n        this.isMoving = true;\r\n        this.isMovingArray = this.isMovingArray.map(value => true);\r\n        return true;\r\n    }\r\n\r\n    move(p5, playBoard) {\r\n        this.accumulate += 1;\r\n        if (this.accumulate >= 20) {\r\n            this.slide(p5, playBoard);\r\n            this.accumulate = 0;\r\n        }\r\n        if (!this.isMoving) {\r\n            this.hasMoved = true;\r\n            plantEnemyInteractions.findMovableAndDelete(playBoard, this);\r\n        }\r\n    }\r\n\r\n    slide(p5, playBoard) {\r\n        let gameOver = false;\r\n        for (let i = 0; i < this.isMovingArray.length; i++) {\r\n            if (this.isMovingArray[i]) {\r\n                if (this.movedLength[i] < this.range[i]) {\r\n                    let cell;\r\n                    if (this.startCol !== -1) {\r\n                        cell = playBoard.boardObjects.getCell(i, this.startCol + this.movedLength[i] + 1);\r\n                        if (cell.terrain.terrainType === terrainTypes.SEA) this.range[i] += 1;\r\n                    } else {\r\n                        cell = playBoard.boardObjects.getCell(this.startRow + this.movedLength[i] + 1, i);\r\n                        if (cell.terrain.terrainType === terrainTypes.SEA) this.range[i] += 1;\r\n                    }\r\n                    this.movedLength[i] += 1;\r\n\r\n                    // interact with plant\r\n                    if(cell.plant || cell.seed){\r\n                        // decrease max range according to plant health\r\n                        // if the plant is palm, invoke its passive skill (placeholder)\r\n                        if(cell?.plant.plantType === plantTypes.PALM) {\r\n\r\n                        }\r\n                        // else, use health to offset range\r\n                        else{\r\n                            let health = cell.seed ? 1 : cell.plant.health;\r\n                            while(health > 0){\r\n                                this.blocker[i]-=1;\r\n                                if(this.blocker[i] <= 0){\r\n                                    this.range[i] -=1;\r\n                                    this.blocker[i] = this.blockerLimit;\r\n                                }\r\n                                health--;\r\n                            }\r\n                        }\r\n\r\n                        if (cell.plant) {\r\n                            cell.removePlant();\r\n                            playBoard.fertilized[cell.x][cell.y] = true;\r\n                        }\r\n                        if (cell.seed) {\r\n                            cell.removeSeed();\r\n                            playBoard.fertilized[cell.x][cell.y] = true;\r\n                        }\r\n                    }\r\n\r\n                    // interact with enemy\r\n                    if (cell.enemy?.enemyType === enemyTypes.BANDIT) {\r\n                        plantEnemyInteractions.findMovableAndDelete(playBoard, cell.enemy);\r\n                    }\r\n\r\n                    // interact with terrain\r\n                    switch(cell.terrain.terrainType){\r\n                        case terrainTypes.BASE:\r\n                            gameOver = true;\r\n                            break;\r\n                        case terrainTypes.VOLCANO:\r\n                        case terrainTypes.MOUNTAIN:\r\n                            this.range[i] = 0;\r\n                            break;\r\n                        case terrainTypes.LUMBERING:\r\n                            this.range[i]-=1;\r\n                            break;\r\n                    }\r\n                } else {\r\n                    this.isMovingArray[i] = false;\r\n                }\r\n            }\r\n            if(gameOver) myutil.gameOver(playBoard);\r\n        }\r\n\r\n        if (!this.checkIsMoving()) this.isMoving = false;\r\n    }\r\n\r\n    stringify() {\r\n        const object = {\r\n            enemyType: this.enemyType,\r\n            startCol: this.startCol,\r\n            startRow: this.startRow,\r\n            range: this.range[0],\r\n            blockerLimit: this.blockerLimit[0],\r\n        }\r\n        return JSON.stringify(object);\r\n    }\r\n\r\n    static parse(json, p5, playBoard) {\r\n        const object = JSON.parse(json);\r\n        return  new TsunamiAnimation(p5, playBoard, object.startCol, object.startRow, object.range, object.blockerLimit);\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/items/TsunamiAnimation.js b/docs/src/items/TsunamiAnimation.js
--- a/docs/src/items/TsunamiAnimation.js	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ b/docs/src/items/TsunamiAnimation.js	(date 1744215531303)
@@ -111,32 +111,35 @@
                     this.movedLength[i] += 1;
 
                     // interact with plant
-                    if(cell.plant || cell.seed){
+                    if (cell.plant || cell.seed) {
                         // decrease max range according to plant health
                         // if the plant is palm, invoke its passive skill (placeholder)
-                        if(cell?.plant.plantType === plantTypes.PALM) {
-
+                        if (cell?.plant.plantType === plantTypes.PALM) {
+                            cell.plant.health--;
+                            if (cell.plant.health === 0) {
+                                plantEnemyInteractions.findPlantAndDelete(playBoard, cell.plant);
+                            }
+                            this.range[i] -= 2;
                         }
                         // else, use health to offset range
-                        else{
+                        else {
                             let health = cell.seed ? 1 : cell.plant.health;
-                            while(health > 0){
-                                this.blocker[i]-=1;
-                                if(this.blocker[i] <= 0){
-                                    this.range[i] -=1;
+                            while (health > 0) {
+                                this.blocker[i] -= 1;
+                                if (this.blocker[i] <= 0) {
+                                    this.range[i] -= 1;
                                     this.blocker[i] = this.blockerLimit;
                                 }
                                 health--;
                             }
-                        }
-
-                        if (cell.plant) {
-                            cell.removePlant();
-                            playBoard.fertilized[cell.x][cell.y] = true;
-                        }
-                        if (cell.seed) {
-                            cell.removeSeed();
-                            playBoard.fertilized[cell.x][cell.y] = true;
+                            if (cell.plant) {
+                                cell.removePlant();
+                                playBoard.fertilized[cell.x][cell.y] = true;
+                            }
+                            if (cell.seed) {
+                                cell.removeSeed();
+                                playBoard.fertilized[cell.x][cell.y] = true;
+                            }
                         }
                     }
 
@@ -146,7 +149,7 @@
                     }
 
                     // interact with terrain
-                    switch(cell.terrain.terrainType){
+                    switch (cell.terrain.terrainType) {
                         case terrainTypes.BASE:
                             gameOver = true;
                             break;
@@ -155,14 +158,14 @@
                             this.range[i] = 0;
                             break;
                         case terrainTypes.LUMBERING:
-                            this.range[i]-=1;
+                            this.range[i] -= 1;
                             break;
                     }
                 } else {
                     this.isMovingArray[i] = false;
                 }
             }
-            if(gameOver) myutil.gameOver(playBoard);
+            if (gameOver) myutil.gameOver(playBoard);
         }
 
         if (!this.checkIsMoving()) this.isMoving = false;
@@ -181,6 +184,6 @@
 
     static parse(json, p5, playBoard) {
         const object = JSON.parse(json);
-        return  new TsunamiAnimation(p5, playBoard, object.startCol, object.startRow, object.range, object.blockerLimit);
+        return new TsunamiAnimation(p5, playBoard, object.startCol, object.startRow, object.range, object.blockerLimit);
     }
 }
\ No newline at end of file
Index: docs/src/model/stages/Tsu1.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {stageGroup} from \"../GameState.js\";\r\nimport {myutil} from \"../../../lib/myutil.js\";\r\nimport {BoardCells} from \"../BoardCells.js\";\r\nimport {Steppe} from \"../../items/Steppe.js\";\r\nimport {PlayerBase} from \"../../items/PlayerBase.js\";\r\nimport {Sea} from \"../../items/Sea.js\";\r\nimport {TsunamiAnimation} from \"../../items/TsunamiAnimation.js\";\r\nimport {Mountain} from \"../../items/Mountain.js\";\r\nimport {BlizzardPlayBoard} from \"./BlizzardPlayboard.js\";\r\n\r\nexport class Tsunami1PlayBoard extends BlizzardPlayBoard {\r\n    constructor(gameState) {\r\n        super(gameState);\r\n        this.stageGroup = stageGroup.TSUNAMI;\r\n        this.stageNumbering = \"5-1\";\r\n        // grid parameters\r\n        this.gridSize = 16;\r\n        [this.cellWidth, this.cellHeight] = myutil.relative2absolute(1 / 20, 4 / 45);\r\n\r\n        // board objects array\r\n        this.boardObjects = new BoardCells(this.gridSize);\r\n\r\n        // turn counter\r\n        this.turn = 1;\r\n        this.maxTurn = 30;\r\n\r\n        // record fertilized cells -- only this stage\r\n        this.fertilized = Array.from({length: this.gridSize},\r\n            () => Array.from({length: this.gridSize}, () => false));\r\n    }\r\n\r\n    setSeedCountdown(x, y) {\r\n        let cell = this.boardObjects.getCell(x, y);\r\n        if (cell.seed && this.fertilized[x][y]) {\r\n            cell.seed.countdown = 1;\r\n        }\r\n    }\r\n\r\n    // set stage inventory at entering, called by controller\r\n    setStageInventory(p5) {\r\n        this.gameState.inventory.pushItem2Inventory(p5, \"Tree\", 10);\r\n        this.gameState.inventory.pushItem2Inventory(p5, \"Bush\", 10);\r\n        this.gameState.inventory.pushItem2Inventory(p5, \"Orchid\", 10);\r\n        this.gameState.inventory.pushItem2Inventory(p5, \"FireHerb\", 10);\r\n        this.gameState.inventory.pushItem2Inventory(p5, \"Bamboo\", 10);\r\n        this.gameState.inventory.pushItem2Inventory(p5, \"Plum\", 10);\r\n        this.gameState.inventory.pushItem2Inventory(p5, \"Kiku\", 10);\r\n        this.gameState.inventory.pushItem2Inventory(p5, \"TreeSeed\", 10);\r\n        this.gameState.inventory.pushItem2Inventory(p5, \"BushSeed\", 10);\r\n        this.gameState.inventory.pushItem2Inventory(p5, \"OrchidSeed\", 10);\r\n    }\r\n\r\n    // set stage terrain, called when the stage is loaded or reset\r\n    setStageTerrain(p5) {\r\n        for (let i = 0; i < this.gridSize; i++) {\r\n            for (let j = 0; j < this.gridSize; j++) {\r\n                if (j >= 8) {\r\n                    this.boardObjects.setCell(i, j, new Steppe(p5));\r\n                } else {\r\n                    this.boardObjects.setCell(i, j, new Sea(p5));\r\n                }\r\n            }\r\n        }\r\n        this.boardObjects.setCell(8, 15, new PlayerBase(p5));\r\n        this.boardObjects.setCell(7, 8, new Mountain(p5));\r\n        this.boardObjects.setCell(7, 9, new PlayerBase(p5));\r\n    }\r\n\r\n    nextTurnItems(p5) {\r\n        if(this.turn === 2) TsunamiAnimation.createNewTsunami(p5, this, 1, -1, 5);\r\n    }\r\n\r\n    modifyBoard(p5, code) {\r\n    }\r\n\r\n    setFloatingWindow(p5) {\r\n        if (this.turn === this.maxTurn + 1) {\r\n            if (this.allFloatingWindows.has(\"000\")) {\r\n                this.floatingWindow = this.allFloatingWindows.get(\"000\");\r\n                this.allFloatingWindows.delete(\"000\");\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    initAllFloatingWindows(p5) {\r\n        let afw = new Map();\r\n\r\n        myutil.commonFloatingWindows(p5, afw);\r\n\r\n        this.allFloatingWindows = afw;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/model/stages/Tsu1.js b/docs/src/model/stages/Tsu1.js
--- a/docs/src/model/stages/Tsu1.js	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ b/docs/src/model/stages/Tsu1.js	(date 1744215531309)
@@ -38,6 +38,7 @@
 
     // set stage inventory at entering, called by controller
     setStageInventory(p5) {
+        this.gameState.inventory.pushItem2Inventory(p5, "Palm", 10);
         this.gameState.inventory.pushItem2Inventory(p5, "Tree", 10);
         this.gameState.inventory.pushItem2Inventory(p5, "Bush", 10);
         this.gameState.inventory.pushItem2Inventory(p5, "Orchid", 10);
@@ -68,6 +69,9 @@
 
     nextTurnItems(p5) {
         if(this.turn === 2) TsunamiAnimation.createNewTsunami(p5, this, 1, -1, 5);
+        if(this.turn === 3) TsunamiAnimation.createNewTsunami(p5, this, 2, -1, 5);
+        if(this.turn === 4) TsunamiAnimation.createNewTsunami(p5, this, 3, -1, 5);
+        if(this.turn === 5) TsunamiAnimation.createNewTsunami(p5, this, 4, -1, 5);
     }
 
     modifyBoard(p5, code) {
Index: documents/Heuristic Evaluation.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>## Heuristic Evaluation\r\n| **Interface** | **Issue** | **Heuristic(s)** | **Frequency** (0-4) | **Impact** (0-4) | **Persistence** (0-4) | **Severity** = (F+I+P)/3 |\r\n| --- | --- | --- | --- | --- | --- | --- |\r\n| UI/UX | Missing **Help Button**, making it difficult for players to get quick assistance | Help & Documentation | 3 | 3 | 3 | 3.00 |\r\n| UI/UX | Title and background design are unclear, affecting immersion | Aesthetic & Minimalist Design | 2 | 2 | 2 | 2.00 |\r\n| UI/UX | Latin placeholder text remains in the game, affecting comprehension | Match Between System & Real World | 2 | 2 | 2 | 2.00 |\r\n| Gameplay | No rewards after defending against a tornado, reducing gameplay satisfaction | Consistency & Standards | 3 | 4 | 3 | 3.33 |\r\n| UI/UX | Lack of a clear announcement when the game ends, leaving players uncertain | Visibility of System Status | 3 | 3 | 3 | 3.00 |\r\n| Gameplay | In the tutorial, resource amounts increase on the second playthrough without explanation | Consistency & Standards | 2 | 3 | 3 | 2.67 |\r\n| UI/UX | **Gameplay is not intuitive, and core mechanics are unclear** | Recognition Rather Than Recall | 4 | 4 | 4 | 4.00 |\r\n| UI/UX | **Players only discover the stamina bar in the second level, second round** | Visibility of System Status | 4 | 4 | 4 | 4.00 |\r\n| Gameplay | The logic of natural disasters and enemy directions is unclear, affecting strategic planning | Match Between System & Real World | 4 | 4 | 4 | 4.00 |\r\n| Gameplay | **Lack of ecosystem hints, affecting strategy formulation** | Help & Documentation | 3 | 4 | 3 | 3.33 |\r\n| Gameplay | **Victory conditions lack diversity, potentially affecting gameplay experience** | Flexibility & Efficiency of Use | 3 | 3 | 3 | 3.00 |\r\n| UI/UX | **Resource values lack clear meaning (Magic Number issue)** | Consistency & Standards | 4 | 4 | 3 | 3.67 |\r\n| UI/UX | **Game hints and annotations are not separated, affecting readability** | Visibility of System Status | 3 | 3 | 3 | 3.00 |\r\n| Gameplay | **Significant difficulty gap between the tutorial and the first level, impacting new player experience** | Consistency & Standards | 4 | 4 | 3 | 3.67 |\r\n| UI/UX | Hovering or clicking should display corresponding hints | Recognition Rather Than Recall | 3 | 3 | 3 | 3.00 |\r\n| UI/UX | Unable to change plant selection after clicking, reducing fluidity | User Control & Freedom | 3 | 3 | 3 | 3.00 |\r\n| UI/UX | Hint transition speed is too slow, affecting gameplay flow | Visibility of System Status | 2 | 3 | 3 | 2.67 |\r\n| UI/UX | Hint text is currently displayed at grid coordinates, should be highlighted instead | Visibility of System Status | 3 | 3 | 3 | 3.00 |\r\n| Gameplay | Players should be able to plant by pressing the spacebar to improve efficiency | Flexibility & Efficiency of Use | 2 | 3 | 3 | 2.67 |\r\n| Gameplay | Players should be able to undo the previous turn to avoid mistakes | User Control & Freedom | 4 | 4 | 4 | 4.00 |\r\n| Gameplay | Players should be able to withdraw a recently planted plant to increase strategic flexibility | User Control & Freedom | 3 | 3 | 3 | 3.00 |\r\n| UI/UX | The arrow on the hint window should fade or disappear when no hint is available | Aesthetic & Minimalist Design | 2 | 2 | 2 | 2.00 |\r\n| Gameplay | **The game may automatically skip the first round, affecting turn-based strategy** | Consistency & Standards | 4 | 4 | 4 | 4.00 |\r\n| UI/UX | **Players with turn-based tactics experience adapt quickly, while new players struggle with a steep learning curve** | Help & Documentation | 4 | 4 | 4 | 4.00 |\r\n\r\n---\r\n\r\n| **Interface** | **Issue** | **Heuristic(s)** | **Frequency** (0-4) | **Impact** (0-4) | **Persistence** (0-4) | **Severity** = (F+I+P)/3 |\r\n| --- | --- | --- | --- | --- | --- | --- |\r\n| UI/UX | 缺少 **Help Button**，玩家可能無法快速獲得幫助 | Help & Documentation | 3 | 3 | 3 | 3.00 |\r\n| UI/UX | 標題、背景設計不清晰，影響沉浸感 | Aesthetic & Minimalist Design | 2 | 2 | 2 | 2.00 |\r\n| UI/UX | 遊戲內仍有拉丁文占位符，影響理解 | Match Between System & Real World | 2 | 2 | 2 | 2.00 |\r\n| Gameplay | 抵禦龍捲風後沒有獎勵，影響遊戲回饋感 | Consistency & Standards | 3 | 4 | 3 | 3.33 |\r\n| UI/UX | 遊戲結束時缺乏明確公告，玩家不確定是否完成 | Visibility of System Status | 3 | 3 | 3 | 3.00 |\r\n| Gameplay | 教學關卡第二次遊玩時，資源變多，未有說明 | Consistency & Standards | 2 | 3 | 3 | 2.67 |\r\n| UI/UX | **遊戲直觀性不足，核心機制不明確** | Recognition Rather Than Recall | 4 | 4 | 4 | 4.00 |\r\n| UI/UX | **玩家到第二關第二回合才知道有“體力條”** | Visibility of System Status | 4 | 4 | 4 | 4.00 |\r\n| Gameplay | 天災、敵人方向的邏輯不清楚，影響戰略判斷 | Match Between System & Real World | 4 | 4 | 4 | 4.00 |\r\n| Gameplay | **缺乏生態系提示，影響策略制定** | Help & Documentation | 3 | 4 | 3 | 3.33 |\r\n| Gameplay | **勝利條件未多元化，可能影響可玩性** | Flexibility & Efficiency of Use | 3 | 3 | 3 | 3.00 |\r\n| UI/UX | **資源數值未標示具體意義（Magic Number）** | Consistency & Standards | 4 | 4 | 3 | 3.67 |\r\n| UI/UX | **遊戲提示與備註未分開，影響可讀性** | Visibility of System Status | 3 | 3 | 3 | 3.00 |\r\n| Gameplay | **教學關卡與第一關難度差異過大，新手體驗受影響** | Consistency & Standards | 4 | 4 | 3 | 3.67 |\r\n| UI/UX | 滑鼠懸停或點擊應顯示相應提示 | Recognition Rather Than Recall | 3 | 3 | 3 | 3.00 |\r\n| UI/UX | 點擊植物後無法更換，影響流暢度 | User Control & Freedom | 3 | 3 | 3 | 3.00 |\r\n| UI/UX | 提示變換速度過慢，影響遊戲流暢度 | Visibility of System Status | 2 | 3 | 3 | 2.67 |\r\n| UI/UX | 提示文字目前以格子座標顯示，建議改為高亮 | Visibility of System Status | 3 | 3 | 3 | 3.00 |\r\n| Gameplay | 玩家應可按空格鍵直接種植植物，提高效率 | Flexibility & Efficiency of Use | 2 | 3 | 3 | 2.67 |\r\n| Gameplay | 玩家應可回到上一回合，以避免錯誤影響 | User Control & Freedom | 4 | 4 | 4 | 4.00 |\r\n| Gameplay | 玩家應可撤回上一個種植的植物，提高策略彈性 | User Control & Freedom | 3 | 3 | 3 | 3.00 |\r\n| UI/UX | 提示窗箭頭應在無提示時淡化或消失 | Aesthetic & Minimalist Design | 2 | 2 | 2 | 2.00 |\r\n| Gameplay | **遊戲有機率自動跳過第一回合，影響回合策略** | Consistency & Standards | 4 | 4 | 4 | 4.00 |\r\n| UI/UX | **戰棋類經驗玩家較易上手，但新手學習成本過高** | Help & Documentation | 4 | 4 | 4 | 4.00 |\r\n\r\n---\r\n\r\n### **關鍵問題與優先處理建議**\r\n\r\n### **最高優先處理（Severity ≥ 3.67）**\r\n\r\n1. **遊戲直觀性嚴重不足，核心機制不明確（4.00）→ 建議**：增加更清晰的遊戲引導，透過視覺提示與新手教程降低學習曲線。\r\n2. **第二關第二回合才顯示體力條（4.00）→ 建議**：在教學階段或第一關開始時，就顯示並解釋體力條的用途。\r\n3. **天災、敵人方向邏輯不清晰（4.00）→ 建議**：透過動畫或圖示標示敵人方向，提高戰略判斷的可預測性。\r\n4. **資源數字（Magic Number）無明確意義（3.67）→ 建議**：提供更直觀的數字標示（如單位、效果），讓玩家能理解數據意涵。\r\n5. **教學關卡與正式關卡難度差異過大（3.67）→ 建議**：調整教學關卡難度，讓玩家有更自然的適應過程。\r\n\r\n### **次要修正（Severity 3.00 - 3.33）**\r\n\r\n1. **勝利條件未多元化，可能影響可玩性（3.00）→ 建議**：增加不同過關條件，如時間限制、生態恢復目標等，提升遊戲策略選擇。\r\n2. **遊戲提示與備註未分開，影響可讀性（3.00）→ 建議**：分離提示與備註資訊，使遊戲內提示不會與遊戲進行資訊混淆。\r\n3. **點擊植物後無法更換，影響操作流暢性（3.00）→ 建議**：允許玩家在一定時間內撤回或更改選擇，提高操作靈活性。\r\n4. **遊戲有機率自動跳過第一回合，影響策略體驗（4.00）→ 建議**：確認 Bug，確保所有回合操作都是由玩家觸發。\r\n5. **回合撤回功能缺失（4.00）→ 建議**：允許玩家回撤至少一步操作，避免策略錯誤導致挫敗感。
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/documents/Heuristic Evaluation.md b/documents/Heuristic Evaluation.md
--- a/documents/Heuristic Evaluation.md	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ b/documents/Heuristic Evaluation.md	(date 1744215531310)
@@ -73,4 +73,68 @@
 2. **遊戲提示與備註未分開，影響可讀性（3.00）→ 建議**：分離提示與備註資訊，使遊戲內提示不會與遊戲進行資訊混淆。
 3. **點擊植物後無法更換，影響操作流暢性（3.00）→ 建議**：允許玩家在一定時間內撤回或更改選擇，提高操作靈活性。
 4. **遊戲有機率自動跳過第一回合，影響策略體驗（4.00）→ 建議**：確認 Bug，確保所有回合操作都是由玩家觸發。
-5. **回合撤回功能缺失（4.00）→ 建議**：允許玩家回撤至少一步操作，避免策略錯誤導致挫敗感。
\ No newline at end of file
+5. **回合撤回功能缺失（4.00）→ 建議**：允許玩家回撤至少一步操作，避免策略錯誤導致挫敗感。
+
+---
+## System Usability Scale
+| Tester/Questions | Question 1 | Question 2 | Question 3 | Question 4 | Question 5 | Question 6 | Question 7 | Question 8 | Question 9 | Question 10 |
+| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
+| Questions | 1. Think that I would like to use this system frequently. | 2. I found the System unnecessarily complex. | 3. I thought the system was easy to use. | 4. I think that I would need the support of a technical person to be able to use this system. | 5. I found the various functions in this system were well integrated. | 6. I though there was too much inconsistency in this system. | 7. I would imagine to use this system very quickly. | 8. I found the system very cumbersome to use. | 9. I felt confident using the system. | 10. I needed to learn a lot of things before I could get going with this system. |
+| Person 1 (Easy level) | 3 | 2 | 2 | 4 | 2 | 4 | 2 | 4 | 4 | 4 |
+| Person 1 (Hard level) | 3 | 2 | 2 | 4 | 3 | 3 | 2 | 3 | 2 | 4 |
+| Person 2 (Easy level) | 2 | 5 | 1 | 5 | 4 | 3 | 2 | 4 | 2 | 4 |
+| Person 2 (Hard level) | 4 | 2 | 3 | 3 | 4 | 2 | 2 | 2 | 4 | 2 |
+| Person 3 (Easy level) | 2 | 1 | 1 | 5 | 3 | 1 | 1 | 4 | 2 | 5 |
+| Person 3 (Hard level) | 3 | 5 | 1 | 5 | 2 | 4 | 2 | 4 | 2 | 5 |
+| Person 4 (Easy level) | 2 | 3 | 4 | 3 | 5 | 1 | 2 | 3 | 1 | 2 |
+| Person 4 (Hard level) | 1 | 4 | 1 | 5 | 3 | 1 | 1 | 4 | 1 | 5 |
+| Person 5 (Easy level) | 4 | 4 | 3 | 3 | 4 | 3 | 5 | 3 | 5 | 4 |
+| Person 5 (Hard level) | 2 | 3 | 2 | 5 | 4 | 2 | 3 | 3 | 2 | 5 |
+| Person 6 (Easy level) | 4 | 2 | 4 | 4 | 4 | 3 | 4 | 4 | 5 | 4 |
+| Person 6 (Hard level) | 3 | 4 | 4 | 4 | 4 | 4 | 3 | 4 | 5 | 4 |
+| Person 7 (Easy level) | 4 | 2 | 3 | 5 | 4 | 2 | 2 | 2 | 3 | 4 |
+| Person 7 (Hard level) | 3 | 3 | 3 | 5 | 4 | 3 | 2 | 3 | 2 | 4 |
+| Person 8 (Easy level) |  |  |  |  |  |  |  |  |  |  |
+| Person 8 (Hard level) |  |  |  |  |  |  |  |  |  |  |
+| Person 9 (Easy level) |  |  |  |  |  |  |  |  |  |  |
+| Person 9 (Hard level) |  |  |  |  |  |  |  |  |  |  |
+| Person 10 (Easy level) |  |  |  |  |  |  |  |  |  |  |
+| Person 10 (Hard level) |  |  |  |  |  |  |  |  |  |  |
+| Person 11 (Easy level) |  |  |  |  |  |  |  |  |  |  |
+| Person 11 (Hard level) |  |  |  |  |  |  |  |  |  |  |
+| Person 12 (Easy level) |  |  |  |  |  |  |  |  |  |  |
+| Person 12 (Hard level) |  |  |  |  |  |  |  |  |  |  |
+
+---
+
+## NASA TLX
+| Tester/Questions | Question 1 | Question 2 | Question 3 | Question 4 | Question 5 | Question 6 |
+| --- | --- | --- | --- | --- | --- | --- |
+| Questions | 1. How mentally demanding was the task? | 2. How physically demanding was the task? | 3. How hurried or rushed was the pace of the task? | 4. How successful were you in accomplishing what you were asked to do? | 5. How hard did you have to work to accomplish your level of performance? | 6. How insecure, discouraged, irritated, stressed, and annoyed were yout? |
+| Person 1 (Easy level) | 15 | 3 | 2 | 9 | 11 | 12 |
+| Person 1 (Hard level) | 14 | 4 | 3 | 12 | 11 | 5 |
+| Person 2 (Easy level) | 16 | 2 | 1 | 16 | 15 | 16 |
+| Person 2 (Hard level) | 11 | 7 | 5 | 9 | 14 | 11 |
+| Person 3 (Easy level) | 10 | 10 | 1 | 1 | 4 | 7 |
+| Person 3 (Hard level) | 15 | 4 | 4 | 10 | 11 | 12 |
+| Person 4 (Easy level) | 7 | 1 | 2 | 1 | 1 | 7 |
+| Person 4 (Hard level) | 8 | 8 | 1 | 5 | 16 | 13 |
+| Person 5 (Easy level) | 5 | 5 | 4 | 1 | 1 | 1 |
+| Person 5 (Hard level) | 16 | 8 | 3 | 14 | 15 | 17 |
+| Person 6 (Easy level) | 3 | 3 | 3 | 2 | 3 | 3 |
+| Person 6 (Hard level) | 6 | 5 | 5 | 2 | 3 | 5 |
+| Person 7 (Easy level) | 12 | 1 | 1 | 7 | 11 | 10 |
+| Person 7 (Hard level) | 17 | 3 | 4 | 12 | 12 | 11 |
+| Person 8 (Easy level) |  |  |  |  |  |  |
+| Person 8 (Hard level) |  |  |  |  |  |  |
+| Person 9 (Easy level) |  |  |  |  |  |  |
+| Person 9 (Hard level) |  |  |  |  |  |  |
+| Person 10 (Easy level) |  |  |  |  |  |  |
+| Person 10 (Hard level) |  |  |  |  |  |  |
+| Person 11 (Easy level) |  |  |  |  |  |  |
+| Person 11 (Hard level) |  |  |  |  |  |  |
+| Person 12 (Easy level) |  |  |  |  |  |  |
+| Person 12 (Hard level) |  |  |  |  |  |  |
+
+---
+
Index: docs/lib/myutil.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {CanvasSize} from \"../src/CanvasSize.js\"\r\nimport {FloatingWindow} from \"../src/model/FloatingWindow.js\";\r\nimport {terrainTypes} from \"../src/items/ItemTypes.js\";\r\nimport {Bandit} from \"../src/items/Bandit.js\";\r\nimport {Tornado} from \"../src/items/Tornado.js\";\r\n\r\nexport class myutil {\r\n\r\n    static relative2absolute(xPercent, yPercent) {\r\n\r\n        if (xPercent < 0 || xPercent > 1 || yPercent < 0 || yPercent > 1) {\r\n            console.error(`input of relative2absolute (${xPercent}, ${yPercent}) are not percentages.`);\r\n            return [-1];\r\n        }\r\n\r\n        return [xPercent * CanvasSize.getSize()[0], yPercent * CanvasSize.getSize()[1]];\r\n    }\r\n\r\n    static absolute2Relative(xAbsolute, yAbsolute) {\r\n\r\n        if (xAbsolute < 0 || xAbsolute > CanvasSize.getSize()[0] || yAbsolute < 0 || yAbsolute > CanvasSize.getSize()[1]) {\r\n            console.error(`input of absolute2Relative (${xAbsolute}, ${yAbsolute}) is not valid position.`);\r\n            return [-1];\r\n        }\r\n\r\n        return [xAbsolute / CanvasSize.getSize()[0], yAbsolute / CanvasSize.getSize()[1]];\r\n    }\r\n\r\n    static manhattanDistance(x0, y0, x1, y1) {\r\n        return Math.abs(x0 - x1) + Math.abs(y0 - y1);\r\n    }\r\n\r\n    static euclideanDistance(x0, y0, x1, y1) {\r\n        return Math.abs(x0 - x1) ** 2 + Math.abs(y0 - y1) ** 2;\r\n    }\r\n\r\n    static findAlternativeCell(sx, sy, tx, ty, x0, y0) {\r\n        let directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];\r\n        let dist = myutil.manhattanDistance(x0, y0, tx, ty);\r\n        for (let [dx, dy] of directions) {\r\n            let x1 = sx + dx;\r\n            let y1 = sy + dy;\r\n            if (x1 === x0 && y1 === y0) continue;\r\n            if (myutil.manhattanDistance(x1, y1, tx, ty) === dist) {\r\n                return [x1, y1];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    static drawHealthBar(p5, item, x, y, width, height) {\r\n        p5.stroke(0);\r\n        p5.strokeWeight(2);\r\n        p5.fill(255, 255, 255, 0);\r\n        p5.rect(x, y, width, height);\r\n\r\n        let p = item.health / item.maxHealth;\r\n\r\n        p5.noStroke();\r\n        p5.fill(\"green\");\r\n        p5.rect(x, y, width * p, height);\r\n\r\n        for (let i = 1; i < item.maxHealth; i++) {\r\n            p5.stroke(0);\r\n            p5.strokeWeight(1);\r\n            p5.line(x + i * width / item.maxHealth, y, x + i * width / item.maxHealth, y + height);\r\n        }\r\n    }\r\n\r\n    static drawActionPoints(p5, playBoard) {\r\n        if (playBoard.hasActionPoints) {\r\n            let [x, y] = myutil.relative2absolute(0.6, 0.01);\r\n            let [width, height] = myutil.relative2absolute(0.07 * 9 / 16, 0.07);\r\n            p5.stroke(\"#DDDDDD\");\r\n            p5.strokeWeight(2);\r\n            p5.fill(\"#DDDDDD\");\r\n            p5.rect(x, y, width, height, 20);\r\n\r\n            p5.noStroke();\r\n            if(playBoard.actionPoints !== 0){\r\n                p5.fill(\"#6699FF\");\r\n            }\r\n            else{\r\n                p5.fill(\"rgba(102,153,255,0.5)\");\r\n            }\r\n            p5.rect(x, y, width, height, 20);\r\n\r\n            p5.fill(255);\r\n            p5.textSize(15);\r\n            p5.textAlign(p5.CENTER, p5.CENTER);\r\n            p5.text(playBoard.actionPoints + \" / \" + playBoard.maxActionPoints,x + width / 2, y + height / 2);\r\n        }\r\n    }\r\n\r\n    // when the main base is destroyed, invoke this function to display game over floating window\r\n    static gameOver(playBoard) {\r\n        if (playBoard.allFloatingWindows.has(\"001\")) {\r\n            playBoard.floatingWindow = playBoard.allFloatingWindows.get(\"001\");\r\n            playBoard.allFloatingWindows.delete(\"001\");\r\n        } else {\r\n            console.error(\"playBoard does not have game over floating window?\");\r\n        }\r\n        playBoard.isGameOver = true;\r\n    }\r\n\r\n    static generateRandomEnemy(p5, playBoard){\r\n        let count = 0;\r\n        while(count<20){\r\n            let x = Math.floor(Math.random() * playBoard.gridSize);\r\n            let y = Math.floor(Math.random() * playBoard.gridSize);\r\n            let cell = playBoard.boardObjects.getCell(x, y);\r\n            if(cell.plant === null && cell.enemy=== null && cell.terrain.terrainType === terrainTypes.STEPPE){\r\n                let r = Math.floor(Math.random() * 2);\r\n                switch(r){\r\n                    case 0: Bandit.createNewBandit(p5, playBoard, x, y); break;\r\n                    case 1: Tornado.createNewTornado(p5, playBoard, x, y, myutil.randomDirection()); break;\r\n                }\r\n                return;\r\n            }\r\n            count++; // prevent infinite loops\r\n        }\r\n    }\r\n\r\n    static randomDirection(){\r\n        let r = Math.floor(Math.random() * 4);\r\n        switch (r){\r\n            case 0: return 'u';\r\n            case 1: return 'd';\r\n            case 2: return 'l';\r\n            case 3: return 'r';\r\n        }\r\n    }\r\n\r\n    // convert canvas position into cell index\r\n    static pos2CellIndex(playBoard, x, y) {\r\n        // edges of the grid under old grid-centered coordinates\r\n        let leftEdge = -(playBoard.gridSize * playBoard.cellWidth) / 2;\r\n        let rightEdge = (playBoard.gridSize * playBoard.cellWidth) / 2;\r\n        let topEdge = -(playBoard.gridSize * playBoard.cellHeight) / 2;\r\n        let bottomEdge = (playBoard.gridSize * playBoard.cellHeight) / 2;\r\n\r\n        // mouse position under old grid-centered coordinates\r\n        let oldX = myutil.oldCoorX(playBoard, x - playBoard.canvasWidth / 2, y - playBoard.canvasHeight / 2);\r\n        let oldY = myutil.oldCoorY(playBoard, x - playBoard.canvasWidth / 2, y - playBoard.canvasHeight / 2);\r\n\r\n        // Check if click is within the grid\r\n        if (oldX >= leftEdge && oldX <= rightEdge\r\n            && oldY >= topEdge && oldY <= bottomEdge) {\r\n            let col = Math.floor((oldX + (playBoard.gridSize * playBoard.cellWidth) / 2) / playBoard.cellWidth);\r\n            let row = Math.floor((oldY + (playBoard.gridSize * playBoard.cellHeight) / 2) / playBoard.cellHeight);\r\n            return [row, col];\r\n        } else {\r\n            return [-1];\r\n        }\r\n    }\r\n\r\n    // convert cell index into canvas position\r\n    static cellIndex2Pos(p5, playBoard, i, j, mode) {\r\n        let x = -(playBoard.gridSize * playBoard.cellWidth / 2) + j * playBoard.cellWidth;\r\n        let y = -(playBoard.gridSize * playBoard.cellHeight / 2) + i * playBoard.cellHeight;\r\n\r\n        let x1 = myutil.newCoorX(playBoard, x, y) + playBoard.canvasWidth / 2;\r\n        let y1 = myutil.newCoorY(playBoard, x, y) + playBoard.canvasHeight / 2;\r\n\r\n        if (mode === p5.CORNER) {\r\n            return [x1, y1];\r\n        }\r\n\r\n        let x2 = myutil.newCoorX(playBoard, x + playBoard.cellWidth, y) + playBoard.canvasWidth / 2;\r\n        let y2 = myutil.newCoorY(playBoard, x + playBoard.cellWidth, y) + playBoard.canvasHeight / 2;\r\n        let x3 = myutil.newCoorX(playBoard, x + playBoard.cellWidth, y + playBoard.cellHeight) + playBoard.canvasWidth / 2;\r\n        let y3 = myutil.newCoorY(playBoard, x + playBoard.cellWidth, y + playBoard.cellHeight) + playBoard.canvasHeight / 2;\r\n        let x4 = myutil.newCoorX(playBoard, x, y + playBoard.cellHeight) + playBoard.canvasWidth / 2;\r\n        let y4 = myutil.newCoorY(playBoard, x, y + playBoard.cellHeight) + playBoard.canvasHeight / 2;\r\n\r\n        if (mode === p5.CORNERS) {\r\n            return [x1, y1, x2, y2, x3, y3, x4, y4];\r\n        }\r\n\r\n        if (mode === p5.CENTER) {\r\n            return [(x1 + x2 + x3 + x4) / 4, (y1 + y2 + y3 + y4) / 4];\r\n        }\r\n    }\r\n\r\n    static isCursorInQuad(px, py, x1, y1, x2, y2, x3, y3, x4, y4) {\r\n        function crossProduct(xa, ya, xb, yb, xc, yc) {\r\n            return (xb - xa) * (yc - ya) - (yb - ya) * (xc - xa);\r\n        }\r\n\r\n        let c1 = crossProduct(x1, y1, x2, y2, px, py);\r\n        let c2 = crossProduct(x2, y2, x3, y3, px, py);\r\n        let c3 = crossProduct(x3, y3, x4, y4, px, py);\r\n        let c4 = crossProduct(x4, y4, x1, y1, px, py);\r\n\r\n        return (c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0) || (c1 < 0 && c2 < 0 && c3 < 0 && c4 < 0);\r\n    }\r\n\r\n    static enterFullscreen() {\r\n        let elem = document.documentElement;\r\n        if (elem.requestFullscreen) {\r\n            elem.requestFullscreen();\r\n        } else if (elem.mozRequestFullScreen) { // Firefox\r\n            elem.mozRequestFullScreen();\r\n        } else if (elem.webkitRequestFullscreen) { // Chrome, Safari, Opera\r\n            elem.webkitRequestFullscreen();\r\n        } else if (elem.msRequestFullscreen) { // IE/Edge\r\n            elem.msRequestFullscreen();\r\n        }\r\n    }\r\n\r\n    static exitFullscreen() {\r\n        if (document.exitFullscreen) {\r\n            document.exitFullscreen();\r\n        } else if (document.mozCancelFullScreen) { // Firefox\r\n            document.mozCancelFullScreen();\r\n        } else if (document.webkitExitFullscreen) { // Chrome, Safari, Opera\r\n            document.webkitExitFullscreen();\r\n        } else if (document.msExitFullscreen) { // IE/Edge\r\n            document.msExitFullscreen();\r\n        }\r\n    }\r\n\r\n    // the coordinate transformation is\r\n    // (x')   ( Sx * cos(rot)  Sy * cos(rot+span) ) ( x )\r\n    // (  ) = (                                   ) (   )\r\n    // (y')   ( Sx * sin(rot)  Sy * sin(rot+span) ) ( y )\r\n\r\n    static newCoorX(playBoard, x, y) {\r\n        return x * playBoard.Sx * Math.cos(playBoard.rot) + y * playBoard.Sy * Math.cos(playBoard.span + playBoard.rot);\r\n    }\r\n\r\n    static newCoorY(playBoard, x, y) {\r\n        return playBoard.Hy * (x * playBoard.Sx * Math.sin(playBoard.rot) + y * playBoard.Sy * Math.sin(playBoard.span + playBoard.rot));\r\n    }\r\n\r\n    static oldCoorX(playBoard, newX, newY) {\r\n        return (1 / (playBoard.Sx * playBoard.Sy * Math.sin(playBoard.span))) * (playBoard.Sy * Math.sin(playBoard.rot + playBoard.span) * newX - playBoard.Sy * Math.cos(playBoard.rot + playBoard.span) * newY);\r\n    }\r\n\r\n    static oldCoorY(playBoard, newX, newY) {\r\n        return -(1 / (playBoard.Sx * playBoard.Sy * Math.sin(playBoard.span))) * (playBoard.Sx * Math.sin(playBoard.rot) * newX - playBoard.Sx * Math.cos(playBoard.rot) * newY);\r\n    }\r\n\r\n    static commonFloatingWindows(p5, afw){\r\n        afw.set(\"000\", new FloatingWindow(p5, null, \"{white:Stage Cleared!}\", {\r\n            x: myutil.relative2absolute(1 / 2, 1 / 6)[0],\r\n            y: myutil.relative2absolute(1 / 2, 1 / 6)[1],\r\n            fontSize: 20,\r\n            padding: 10,\r\n            spacingRatio: 0.3,\r\n            fadingSpeed: 1,\r\n            playerCanClick: true\r\n        }));\r\n\r\n        afw.set(\"001\", new FloatingWindow(p5, null, \"{white:Game Over}\", {\r\n            x: myutil.relative2absolute(1 / 2, 1 / 6)[0],\r\n            y: myutil.relative2absolute(1 / 2, 1 / 6)[1],\r\n            fontSize: 20,\r\n            padding: 10,\r\n            spacingRatio: 0.3,\r\n            fadingSpeed: 1,\r\n            playerCanClick: true\r\n        }));\r\n\r\n        afw.set(\"002\", new FloatingWindow(p5, null, \"{white:Out of Action Points!}\", {\r\n            x: myutil.relative2absolute(1 / 2, 1 / 6)[0],\r\n            y: myutil.relative2absolute(1 / 2, 1 / 6)[1],\r\n            fontSize: 20,\r\n            padding: 10,\r\n            spacingRatio: 0.3,\r\n            fadingSpeed: 1,\r\n            playerCanClick: false\r\n        }));\r\n\r\n        afw.set(\"010\", new FloatingWindow(p5, null, \"{white:An enemy is on this cell,}\\\\{white:you can't grow plant here!}\", {\r\n            x: myutil.relative2absolute(1 / 2, 1 / 6)[0],\r\n            y: myutil.relative2absolute(1 / 2, 1 / 6)[1],\r\n            fontSize: 20,\r\n            padding: 10,\r\n            spacingRatio: 0.3,\r\n            fadingSpeed: 1,\r\n            playerCanClick: false\r\n        }));\r\n\r\n        afw.set(\"011\", new FloatingWindow(p5, null, \"{white:A seed or plant is already on this cell,}\\\\{white:you can't grow plant here!}\", {\r\n            x: myutil.relative2absolute(1 / 2, 1 / 6)[0],\r\n            y: myutil.relative2absolute(1 / 2, 1 / 6)[1],\r\n            fontSize: 20,\r\n            padding: 10,\r\n            spacingRatio: 0.3,\r\n            fadingSpeed: 1,\r\n            playerCanClick: false\r\n        }));\r\n\r\n        afw.set(\"012\", new FloatingWindow(p5, null, \"{white:Cannot grow plant on incompatible terrain!}\", {\r\n            x: myutil.relative2absolute(1 / 2, 1 / 6)[0],\r\n            y: myutil.relative2absolute(1 / 2, 1 / 6)[1],\r\n            fontSize: 20,\r\n            padding: 10,\r\n            spacingRatio: 0.3,\r\n            fadingSpeed: 1,\r\n            playerCanClick: false\r\n        }));\r\n\r\n        afw.set(\"020\", new FloatingWindow(p5, null, \"{white:This will reset current turn. Click reset again if you are sure to proceed.}\", {\r\n            x: myutil.relative2absolute(1 / 2, 1 / 6)[0],\r\n            y: myutil.relative2absolute(1 / 2, 1 / 6)[1],\r\n            fontSize: 20,\r\n            padding: 10,\r\n            spacingRatio: 0.3,\r\n            fadingSpeed: 1,\r\n            playerCanClick: true\r\n        }));\r\n\r\n        afw.set(\"021\", new FloatingWindow(p5, null, \"{white:This will undo last action. Click undo again if you are sure to proceed.}\", {\r\n            x: myutil.relative2absolute(1 / 2, 1 / 6)[0],\r\n            y: myutil.relative2absolute(1 / 2, 1 / 6)[1],\r\n            fontSize: 20,\r\n            padding: 10,\r\n            spacingRatio: 0.3,\r\n            fadingSpeed: 1,\r\n            playerCanClick: true\r\n        }));\r\n\r\n        afw.set(\"050\", new FloatingWindow(p5, null, \"{white:Invalid target!}\", {\r\n            x: myutil.relative2absolute(1 / 2, 1 / 6)[0],\r\n            y: myutil.relative2absolute(1 / 2, 1 / 6)[1],\r\n            fontSize: 20,\r\n            padding: 10,\r\n            spacingRatio: 0.3,\r\n            fadingSpeed: 1,\r\n            playerCanClick: false\r\n        }));\r\n\r\n        afw.set(\"051\", new FloatingWindow(p5, null, \"{white:The plant cannot activate skill}\\\\{white:so many times in one turn!}\", {\r\n            x: myutil.relative2absolute(1 / 2, 1 / 6)[0],\r\n            y: myutil.relative2absolute(1 / 2, 1 / 6)[1],\r\n            fontSize: 20,\r\n            padding: 10,\r\n            spacingRatio: 0.3,\r\n            fadingSpeed: 1,\r\n            playerCanClick: false\r\n        }));\r\n\r\n        afw.set(\"052\", new FloatingWindow(p5, null, \"{white:Target is too far away!}\", {\r\n            x: myutil.relative2absolute(1 / 2, 1 / 6)[0],\r\n            y: myutil.relative2absolute(1 / 2, 1 / 6)[1],\r\n            fontSize: 20,\r\n            padding: 10,\r\n            spacingRatio: 0.3,\r\n            fadingSpeed: 1,\r\n            playerCanClick: false\r\n        }));\r\n\r\n        afw.set(\"053\", new FloatingWindow(p5, null, \"{white:You cannot heal a plant not injured!}\", {\r\n            x: myutil.relative2absolute(1 / 2, 1 / 6)[0],\r\n            y: myutil.relative2absolute(1 / 2, 1 / 6)[1],\r\n            fontSize: 20,\r\n            padding: 10,\r\n            spacingRatio: 0.3,\r\n            fadingSpeed: 1,\r\n            playerCanClick: false\r\n        }));\r\n\r\n        afw.set(\"099\", new FloatingWindow(p5, null, \"{white:You have cleared the game!}\", {\r\n            x: myutil.relative2absolute(1 / 2, 1 / 6)[0],\r\n            y: myutil.relative2absolute(1 / 2, 1 / 6)[1],\r\n            fontSize: 20,\r\n            padding: 10,\r\n            spacingRatio: 0.3,\r\n            fadingSpeed: 1,\r\n            playerCanClick: false\r\n        }));\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/lib/myutil.js b/docs/lib/myutil.js
--- a/docs/lib/myutil.js	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ b/docs/lib/myutil.js	(date 1744215531299)
@@ -371,5 +371,25 @@
             fadingSpeed: 1,
             playerCanClick: false
         }));
+
+        afw.set("NoSaveData", new FloatingWindow(p5, null, "{white:No Save Data Found!}", {
+            x: myutil.relative2absolute(1 / 2, 1 / 2)[0],
+            y: myutil.relative2absolute(1 / 2, 1 / 2)[1],
+            fontSize: 20,
+            padding: 10,
+            spacingRatio: 0.3,
+            fadingSpeed: 1,
+            playerCanClick: true
+        }));
+
+        afw.set("GameSaved", new FloatingWindow(p5, null, "{white:Game Saved.}", {
+            x: myutil.relative2absolute(1 / 2, 1 / 2)[0],
+            y: myutil.relative2absolute(1 / 2, 1 / 2)[1],
+            fontSize: 20,
+            padding: 10,
+            spacingRatio: 0.3,
+            fadingSpeed: 1,
+            playerCanClick: true
+        }));
     }
 }
\ No newline at end of file
Index: docs/src/items/MapButton.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/items/MapButton.js b/docs/src/items/MapButton.js
new file mode 100644
--- /dev/null	(date 1744215531302)
+++ b/docs/src/items/MapButton.js	(date 1744215531302)
@@ -0,0 +1,126 @@
+export class MapButton {
+    constructor(x, y, size, img, stageGroup) {
+        this.x = x;
+        this.y = y;
+        this.size = size;
+        this.width = size;
+        this.height = size;
+        this.isLocked = true;
+        this.isCleared = false;
+        this.img = img;
+        this.isHovered = false;
+        this._onClick = (p5) => {
+            console.error("map button's onClick function is not overridden");
+        };
+        this.circle = null;
+        this.stageGroup = stageGroup;
+    }
+
+    draw(p5) {
+        this.isHovered = this.hasMouseOver(p5);
+        let baseColor = "rgb(102, 255, 102)";
+        let hoverColor = "rgb(152, 255, 152)";
+        let buttonColor = this.isHovered ? hoverColor : baseColor;
+        p5.noStroke();
+        // rectangle shape of button
+        p5.fill(buttonColor);
+        p5.rect(this.x, this.y, this.width, this.height, 10); // 10: corner roundedness
+        p5.image(this.img, this.x, this.y, this.width, this.height);
+        if (this.isLocked === true) {
+            p5.fill(100, 100, 100, 100);
+            p5.rect(this.x, this.y, this.width, this.height, 10);
+            p5.image(p5.images.get("Lock"), this.x + this.width / 4, this.y + this.height / 4, this.width / 2, this.height / 2);
+        }
+
+        if (this.circle) this.circle.updateAndDraw(p5);
+    }
+
+    set onClick(func) {
+        this._onClick = func;
+    }
+
+    unlock(gameState) {
+        if (gameState.isStageCleared(this.stageGroup - 1)) {
+            this.isLocked = false;
+        }
+        if (gameState.isStageCleared(this.stageGroup)) {
+            this.isLocked = true;
+            this.isCleared = true;
+        }
+
+    }
+
+    createNewCircle(p5) {
+        this.circle = new CircleAnimation(p5, this.x, this.y, this.size);
+
+    }
+
+    hasMouseOver(p5) {
+        return p5.mouseX > this.x && p5.mouseX < this.x + this.width
+            && p5.mouseY > this.y && p5.mouseY < this.y + this.height;
+    }
+
+    mouseClick(p5) {
+        if (this.hasMouseOver(p5)) {
+            this._onClick(p5);
+            return true;
+        }
+        return false;
+    }
+}
+
+class CircleAnimation {
+    constructor(p5, x, y, size) {
+        this.angleStart = 0.2 * p5.PI;
+        this.angleEnd = 0.2 * p5.PI + 2.3 * p5.PI;
+        this.x = x + size * 0.2;
+        this.y = y + size * 0.2;
+        this.size = size * 0.7;
+        this.radiusAt = (t) => this.size + this.size * (2 / 7) * p5.sin(1.01 * p5.PI * t);
+        this.thicknessAt = (t) => this.size * 0.1 + this.size * 0.1 * 0.5 * p5.noise(t * 5);
+        this.tMax = 0;
+        this.steps = 200;
+    }
+
+    updateAndDraw(p5) {
+        this.update();
+        this.draw(p5);
+    }
+
+    angleAt(p5, t) {
+        return p5.lerp(this.angleStart, this.angleEnd, t);
+    }
+
+    update() {
+        if (this.tMax < 1) {
+            this.tMax += 0.025;
+        }
+    }
+
+    draw(p5) {
+        p5.push();
+        p5.translate(this.x + this.size / 2, this.y + this.size / 2);
+        p5.strokeWeight(1);
+        p5.stroke("rgb(0, 204, 0)");
+        p5.fill("rgb(0, 204, 0)");
+        p5.beginShape(p5.TRIANGLE_STRIP);
+        for (let i = 0; i <= this.steps * this.tMax; i++) {
+            let t = i / this.steps;
+            let a = this.angleAt(p5, t);
+            let r = this.radiusAt(t);
+            let th = this.thicknessAt(t);
+            let outer = r + th / 2;
+            let inner = r - th / 2;
+
+            let x1 = p5.cos(a) * outer;
+            let y1 = p5.sin(a) * outer;
+            let x2 = p5.cos(a) * inner;
+            let y2 = p5.sin(a) * inner;
+
+            p5.vertex(x1, y1);
+            p5.vertex(x2, y2);
+        }
+        p5.endShape();
+        p5.pop();
+    }
+}
\ No newline at end of file
Index: docs/src/items/Palm.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/items/Palm.js b/docs/src/items/Palm.js
new file mode 100644
--- /dev/null	(date 1744215531302)
+++ b/docs/src/items/Palm.js	(date 1744215531302)
@@ -0,0 +1,77 @@
+import {itemTypes, plantTypes, seedTypes} from "./ItemTypes.js";
+import {Plant} from "./Plant.js";
+import {Seed} from "./Seed.js";
+
+export class Palm extends Plant {
+    constructor(p5) {
+        super();
+        this.name = "Palm";
+        this.color = "rgb(126,255,97)";
+        this.plantType = plantTypes.PALM;
+        this.img = p5.images.get(`${this.name}`);
+
+        this.seed = PalmSeed;
+
+        this.health = 3;
+        this.maxHealth = 3;
+        this.status = true;
+    }
+
+    getPassiveString() {
+        return "Dampen tsunami."
+    }
+
+    getActiveString() {
+        return "No active skill.";
+    }
+
+    reevaluateSkills(playBoard, cell) {
+
+    }
+
+    stringify() {
+        const object = {
+            plantType: this.plantType,
+            health: this.health,
+        }
+        if (this.earthCounter) object.earthCounter = this.earthCounter;
+        if (this.coldCounter) object.coldCounter = this.coldCounter;
+        return JSON.stringify(object);
+    }
+
+    static parse(json, p5) {
+        const object = JSON.parse(json);
+        let palm = new Palm(p5);
+        palm.health = object.health;
+        palm.earthCounter = object.earthCounter;
+        palm.coldCounter = object.coldCounter;
+        return palm;
+    }
+}
+
+export class PalmSeed extends Seed {
+    constructor(p5) {
+        super();
+        this.name = "PalmSeed";
+        this.color = "rgb(126,255,97)";
+        this.seedType = seedTypes.PALM;
+        this.countdown = 3;
+        this.img = this.img = p5.images.get("Seed");
+    }
+
+    grow(p5) {
+        this.countdown--;
+        if (this.countdown === 0) {
+            return new Palm(p5);
+        } else {
+            return this;
+        }
+    }
+
+    static parse(json, p5) {
+        const object = JSON.parse(json);
+        let palmSeed = new PalmSeed(p5);
+        palmSeed.countdown = object.countdown;
+        return palmSeed;
+    }
+}
Index: docs/src/model/GameSave.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {GameState, stageGroup, stateCode} from \"./GameState.js\";\r\nimport {Inventory} from \"./Inventory.js\";\r\nimport {PlayBoard} from \"./Play.js\";\r\n\r\nexport class GameSave {\r\n\r\n    static saveDataID = \"GreenRenaissanceSaveData\";\r\n\r\n    static save(p5) {\r\n        let gameState = p5.controller.gameState;\r\n        let state = {\r\n            state: gameState.state,\r\n            currentStageGroup: gameState.currentStageGroup,\r\n            currentStage: gameState.currentStage != null ? gameState.currentStage.saveGame() : null,\r\n            inventory: gameState.currentStage != null ? null : gameState.inventory.stringify(), // prevent double storage of inventory\r\n            clearedStages: JSON.stringify(Array.from(gameState.clearedStages.entries())),\r\n            saveState: p5.controller.saveState,\r\n        }\r\n        localStorage.setItem(GameSave.saveDataID, JSON.stringify(encrypt(JSON.stringify(state))));\r\n        console.log('Game saved');\r\n    }\r\n\r\n    static load(p5) {\r\n        let data = localStorage.getItem(GameSave.saveDataID);\r\n        if (data) {\r\n            let stateObject = JSON.parse(decrypt(JSON.parse(data)));\r\n            let gameState = p5.controller.gameState;\r\n            gameState.state = stateObject.state;\r\n            gameState.currentStageGroup = stateObject.currentStageGroup;\r\n            gameState.inventory = stateObject.inventory ? Inventory.parse(stateObject.inventory, p5) : null;\r\n            gameState.clearedStages = new Map(JSON.parse(stateObject.clearedStages));\r\n            gameState.currentStage = stateObject.currentStage? PlayBoard.loadGame(p5, gameState, stateObject.currentStage) : null;\r\n\r\n            p5.controller.menus[stateCode.PLAY] = gameState.currentStage;\r\n            p5.controller.saveState = stateObject.saveState;\r\n            p5.controller.gameState = gameState;\r\n        } else {\r\n            console.error('Save data not found!');\r\n        }\r\n    }\r\n}\r\n\r\nfunction generateKey(timestamp, keySize) {\r\n    let buffer = new ArrayBuffer(8);\r\n    let view = new DataView(buffer);\r\n    view.setBigInt64(0, BigInt(timestamp));\r\n\r\n    let fullKey = new Uint8Array(buffer);\r\n    return fullKey.slice(8 - keySize);\r\n}\r\n\r\nfunction encrypt(input) {\r\n    const timestamp = Date.now();\r\n    const keySize = 4;\r\n    const key = Array.from(generateKey(timestamp, keySize));\r\n    const inputBytes = Array.from(new TextEncoder().encode(input));\r\n    const encrypted = inputBytes.map((byte, i) => byte ^ key[i % key.length]);\r\n    return [...key, ...encrypted]; // simple number[]\r\n}\r\n\r\nfunction decrypt(encryptedArray) {\r\n    const keySize = 4;\r\n    const key = encryptedArray.slice(0, keySize);\r\n    const encrypted = encryptedArray.slice(keySize);\r\n    const decrypted = encrypted.map((byte, i) => byte ^ key[i % key.length]);\r\n    return new TextDecoder().decode(new Uint8Array(decrypted));\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/model/GameSave.js b/docs/src/model/GameSave.js
--- a/docs/src/model/GameSave.js	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ b/docs/src/model/GameSave.js	(date 1744215531304)
@@ -29,13 +29,17 @@
             gameState.currentStageGroup = stateObject.currentStageGroup;
             gameState.inventory = stateObject.inventory ? Inventory.parse(stateObject.inventory, p5) : null;
             gameState.clearedStages = new Map(JSON.parse(stateObject.clearedStages));
-            gameState.currentStage = stateObject.currentStage? PlayBoard.loadGame(p5, gameState, stateObject.currentStage) : null;
+            gameState.currentStage = stateObject.currentStage ? PlayBoard.loadGame(p5, gameState, stateObject.currentStage) : null;
 
             p5.controller.menus[stateCode.PLAY] = gameState.currentStage;
             p5.controller.saveState = stateObject.saveState;
             p5.controller.gameState = gameState;
+
+            if (gameState.state === stateCode.STANDBY) p5.controller.menus[stateCode.STANDBY].setup(p5);
+            return true;
         } else {
             console.error('Save data not found!');
+            return false;
         }
     }
 }
Index: docs/src/model/Screen.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>export class Screen {\r\n    constructor(gameState) {\r\n        this.gameState = gameState;\r\n        this.buttons = [];\r\n        this.floatingWindow = null;\r\n        this.allFloatingWindows = null;\r\n    }\r\n\r\n    // init buttons and keyboard listeners.\r\n    setup(p5) {\r\n        console.error(\"setup not implemented!\");\r\n    }\r\n\r\n    reset(p5) {\r\n        this.buttons = [];\r\n        this.floatingWindow = null;\r\n        this.allFloatingWindows = null;\r\n        this.setup(p5);\r\n    }\r\n\r\n    handleClick(p5) {\r\n        console.error(\"handleClick not implemented!\");\r\n    }\r\n\r\n    draw(p5) {\r\n        console.error(\"draw not implemented!\");\r\n    }\r\n\r\n    // general logic\r\n    // remember to invoke this method in the most above to ensure logic.\r\n    handleFloatingWindow() {\r\n        if (this.floatingWindow !== null) {\r\n            if (!this.floatingWindow.isFading) {\r\n                this.floatingWindow.isFading = true;\r\n                if (!this.floatingWindow.playerCanClick) {\r\n                    return true;\r\n                }\r\n            }\r\n            if (!this.floatingWindow.playerCanClick) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // general logic\r\n    drawFloatingWindow(p5) {\r\n        this.setFloatingWindow(p5);\r\n        if (this.floatingWindow !== null) {\r\n            if (this.floatingWindow.isFading) {\r\n                this.floatingWindow.fadeOut();\r\n                if (this.floatingWindow.hasFadedOut()) {\r\n                    this.floatingWindow = null;\r\n                } else {\r\n                    this.floatingWindow.draw();\r\n                }\r\n            } else {\r\n                this.floatingWindow.draw();\r\n            }\r\n        }\r\n    }\r\n\r\n    setFloatingWindow(p5) {\r\n        console.error(\"setFloatingWindow not implemented!\");\r\n    }\r\n\r\n    initAllFloatingWindows(p5) {\r\n        console.error(\"initAllFloatingWindows not implemented!\");\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/model/Screen.js b/docs/src/model/Screen.js
--- a/docs/src/model/Screen.js	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ b/docs/src/model/Screen.js	(date 1744215531308)
@@ -22,6 +22,16 @@
         console.error("handleClick not implemented!");
     }
 
+    handleScroll(p5, event) {
+        if (!this.gameState) return;
+        if (p5.mouseX >= this.gameState.inventory.inventoryX
+            && p5.mouseX <= this.gameState.inventory.inventoryX + this.gameState.inventory.inventoryWidth
+            && p5.mouseY >= this.gameState.inventory.inventoryY
+            && p5.mouseY <= this.gameState.inventory.inventoryY + this.gameState.inventory.inventoryHeight) {
+            this.gameState.inventory.handleScroll(event);
+        }
+    }
+
     draw(p5) {
         console.error("draw not implemented!");
     }
Index: docs/src/model/BoardCells.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {baseType, enemyTypes, itemTypes, plantTypes, seedTypes, terrainTypes} from \"../items/ItemTypes.js\";\r\nimport {FloatingWindow} from \"./FloatingWindow.js\";\r\nimport {UnionFind} from \"../controller/UnionFind.js\";\r\nimport {myutil} from \"../../lib/myutil.js\";\r\nimport {stageGroup} from \"./GameState.js\";\r\nimport {Plum, PlumSeed, Snowfield} from \"../items/Blizzard.js\";\r\nimport {Steppe} from \"../items/Steppe.js\";\r\nimport {Lava, Volcano} from \"../items/Volcano.js\";\r\nimport {Tree, TreeSeed} from \"../items/Tree.js\";\r\nimport {Bush, BushSeed} from \"../items/Bush.js\";\r\nimport {Orchid, OrchidSeed} from \"../items/Orchid.js\";\r\nimport {FireHerb, FireHerbSeed} from \"../items/FireHerb.js\";\r\nimport {Bamboo, BambooSeed} from \"../items/Bamboo.js\";\r\nimport {PlayerBase} from \"../items/PlayerBase.js\";\r\nimport {Mountain} from \"../items/Mountain.js\";\r\nimport {Lumbering} from \"../items/Bandit.js\";\r\nimport {Hill, Landslide} from \"../items/Earthquake.js\";\r\nimport {Sea} from \"../items/Sea.js\";\r\nimport {Kiku, KikuSeed} from \"../items/Kiku.js\";\r\n\r\nexport class BoardCells {\r\n    constructor(size) {\r\n        this.size = size;\r\n        // initially the array is empty since we have to\r\n        // manually set terrain for every cell\r\n        this.boardObjects = Array.from({length: this.size},\r\n            () => Array.from({length: this.size}, () => null));\r\n    }\r\n\r\n    // to set terrain, invoke this function\r\n    setCell(x, y, terrain) {\r\n        this.boardObjects[x][y] = new Cell(x, y, terrain);\r\n    }\r\n\r\n    // plant on a cell\r\n    plantCell(p5, playBoard, x, y, item) {\r\n        let cell = this.getCell(x, y);\r\n\r\n        if (item.type !== itemTypes.PLANT && item.type !== itemTypes.SEED) {\r\n            console.error(\"plantCell received invalid input.\");\r\n            return false;\r\n        }\r\n\r\n        if (!cell.isCompatible(playBoard, item)) {\r\n            return false;\r\n        }\r\n\r\n        // the implementation of ecosystem skill: grow faster\r\n        if (item.type === itemTypes.SEED) {\r\n            cell.seed = item;\r\n            if (cell.ecosystem !== null && cell.ecosystem.growFaster) {\r\n                cell.seed.countdown = cell.seed.countdown - 1 < 1 ? 1 : cell.seed.countdown - 1;\r\n            }\r\n            if (cell.terrain.terrainType === terrainTypes.LAVA) {\r\n                cell.seed.countdown = 1;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        cell.plant = item;\r\n\r\n        // reconstruct ecosystem for every transplanting\r\n        this.setEcosystem();\r\n\r\n        // plums dissolve snowfield\r\n        if (item.plantType === plantTypes.PLUM) {\r\n            for (let nCell of this.getNearbyCells(cell.x, cell.y, Plum.plumRange)) {\r\n                if (nCell.terrain.terrainType === terrainTypes.SNOWFIELD) {\r\n                    nCell.terrain = new Steppe(p5);\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    removePlant(x, y) {\r\n        this.getCell(x, y).removePlant();\r\n        this.setEcosystem();\r\n    }\r\n\r\n    getCell(x, y) {\r\n        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {\r\n            return null;\r\n        }\r\n        return this.boardObjects[x][y];\r\n    }\r\n\r\n    getAllCellsWithPlant() {\r\n        let cells = [];\r\n        for (let i = 0; i < this.size; i++) {\r\n            for (let j = 0; j < this.size; j++) {\r\n                if (this.getCell(i, j).plant !== null) {\r\n                    cells.push(this.getCell(i, j));\r\n                }\r\n            }\r\n        }\r\n        return cells;\r\n    }\r\n\r\n    getAllCellsWithSeed() {\r\n        let cells = [];\r\n        for (let i = 0; i < this.size; i++) {\r\n            for (let j = 0; j < this.size; j++) {\r\n                if (this.getCell(i, j).seed !== null) {\r\n                    cells.push(this.getCell(i, j));\r\n                }\r\n            }\r\n        }\r\n        return cells;\r\n    }\r\n\r\n    getAllCellsWithEnemy() {\r\n        let cells = [];\r\n        for (let i = 0; i < this.size; i++) {\r\n            for (let j = 0; j < this.size; j++) {\r\n                if (this.getCell(i, j).enemy !== null) {\r\n                    cells.push(this.getCell(i, j));\r\n                }\r\n            }\r\n        }\r\n        return cells;\r\n    }\r\n\r\n    // return a descriptive string\r\n    getCellString(x, y) {\r\n        if (this.getCell(x, y) === null) {\r\n            return `cell at (${x},${y}) is null!`\r\n        }\r\n\r\n        let t = this.getCell(x, y).terrain;\r\n        let p = this.getCell(x, y).plant;\r\n        let s = this.getCell(x, y).seed;\r\n        let e = this.getCell(x, y).enemy;\r\n\r\n        if (t === null) {\r\n            return `cell at (${x},${y}) is missing terrain!`;\r\n        }\r\n\r\n        if (p === null && s === null && e === null) {\r\n            //return `cell at (${x},${y}) is of terrain ${t.name}.`;\r\n            return `terrain ${t.name}`;\r\n        }\r\n\r\n        if (e !== null) {\r\n            //return `cell at (${x},${y}) is of terrain ${t.name} and has a ${e.name} with health ${e.health}.`;\r\n            return `terrain ${t.name} and has a ${e.name} of health ${e.health}.`;\r\n        }\r\n\r\n        if (s !== null) {\r\n            //return `cell at (${x},${y}) is of terrain ${t.name} and has a ${s.name} which grows up in ${s.countdown} turns.`;\r\n            return `terrain ${t.name} and has a ${s.name} which grows up in ${s.countdown} turns.`;\r\n        }\r\n\r\n        //return `cell at (${x},${y}) is of terrain ${t.name} and has a plant ${p.name} with health ${p.health}.`;\r\n        return `terrain ${t.name} and has a plant ${p.name} of health ${p.health}.`;\r\n    }\r\n\r\n    setEcosystem() {\r\n        let allPlants = this.getAllCellsWithPlant();\r\n        let uf = new UnionFind(allPlants.length);\r\n\r\n        let cellIndexMap = new Map(); // the variables of UF data structure are integers\r\n        allPlants.forEach((c, index) => cellIndexMap.set(c, index));\r\n\r\n        // step1: construct UF. if one plant is in adjacent 8 of another, they are connected.\r\n        for (let i = 0; i < allPlants.length; i++) {\r\n            for (let j = i + 1; j < allPlants.length; j++) {\r\n                let cell1 = allPlants[i];\r\n                let cell2 = allPlants[j];\r\n                if (Math.abs(cell1.x - cell2.x) <= 1 && Math.abs(cell1.y - cell2.y) <= 1) {\r\n                    uf.union(i, j);\r\n                }\r\n            }\r\n        }\r\n\r\n        // step2: get all connected components.\r\n        let connectedComponents = new Map(); // <RootID, componentArray>\r\n        for (let i = 0; i < allPlants.length; i++) {\r\n            let root = uf.find(i);\r\n            if (connectedComponents.has(root)) continue;\r\n            connectedComponents.set(root, uf.getComponent(i).map(index => allPlants[index]));\r\n        }\r\n\r\n        // step3: Determine which components qualify for an ecosystem\r\n        let ecosystemQualification = new Map();\r\n\r\n        for (let [root, component] of connectedComponents.entries()) {\r\n\r\n            // 1. loop through all plants\r\n            for (let cell of component) {\r\n                let plantTypesSet = new Set();\r\n                plantTypesSet.add(baseType(cell.plant));\r\n                // 2. loop through 4 adjacent cells\r\n                for (let adCell of this.getAdjacent4Cells(cell.x, cell.y)) {\r\n                    if (adCell.plant === null) continue;\r\n                    plantTypesSet.add(baseType(adCell.plant));\r\n                    // 3. further loop through 4 adjacent cells\r\n                    for (let adAdCell of this.getAdjacent4Cells(adCell.x, adCell.y)) {\r\n                        if (adAdCell.plant === null) continue;\r\n                        plantTypesSet.add(baseType(adAdCell.plant));\r\n                    }\r\n                }\r\n                // If 3 different plant types exist, mark as ecosystem\r\n                if (plantTypesSet.size >= 3) {\r\n                    ecosystemQualification.set(root, true);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // step4: create and assign ecosystem.\r\n        for (let [root, component] of connectedComponents.entries()) {\r\n            if (!ecosystemQualification.get(root)) continue;\r\n\r\n            let ecosystem = this.createEcosystem(component);\r\n            for (let cell of component) {\r\n                cell.ecosystem = ecosystem;\r\n                for (let adCell of this.getAdjacent8Cells(cell.x, cell.y)) {\r\n                    // tiebreaker: when two ecosystems are overlapped but not connected\r\n                    if (adCell.ecosystem !== null && adCell.ecosystem !== ecosystem && adCell.ecosystem.countPlants >= ecosystem.countPlants) {\r\n                        continue;\r\n                    }\r\n                    adCell.ecosystem = ecosystem;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    createEcosystem(component) {\r\n        let ecosystem = new Ecosystem(component.length);\r\n\r\n        // Assign special abilities\r\n        for (let cell of component) {\r\n            if (cell.plant.plantType === plantTypes.FIRE_HERB && component.length >= 10) {\r\n                ecosystem.rejectLava = true;\r\n                ecosystem.withstandSnow = true;\r\n            }\r\n        }\r\n        return ecosystem;\r\n    }\r\n\r\n\r\n    getAdjacent8Cells(x, y) {\r\n        let cells = [];\r\n        for (let i = -1; i <= 1; i++) {\r\n            for (let j = -1; j <= 1; j++) {\r\n                if (i === 0 && j === 0) {\r\n                    continue;\r\n                }\r\n                if (0 <= x + i && x + i < this.size && 0 <= y + j && y + j < this.size) {\r\n                    cells.push(this.getCell(x + i, y + j));\r\n                }\r\n            }\r\n        }\r\n        return cells;\r\n    }\r\n\r\n    getAdjacent4Cells(x, y) {\r\n        let cells = [];\r\n        let directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\r\n        for (let [i, j] of directions) {\r\n            if (0 <= x + i && x + i < this.size && 0 <= y + j && y + j < this.size) {\r\n                cells.push(this.getCell(x + i, y + j));\r\n            }\r\n        }\r\n        return cells;\r\n    }\r\n\r\n    getNearbyCells(x, y, range) {\r\n        let cells = [];\r\n        for (let i = 0; i < this.size; i++) {\r\n            for (let j = 0; j < this.size; j++) {\r\n                if (range(x, y, i, j)) {\r\n                    cells.push(this.getCell(i, j));\r\n                }\r\n            }\r\n        }\r\n        return cells;\r\n    }\r\n\r\n    stringify() {\r\n        const object = {\r\n            size: this.size,\r\n            boardObjects: Array.from({length: this.size},\r\n                () => Array.from({length: this.size}, () => null))\r\n        }\r\n        for (let i = 0; i < object.boardObjects.length; i++) {\r\n            for (let j = 0; j < object.boardObjects[i].length; j++) {\r\n                object.boardObjects[i][j] = this.getCell(i, j).stringify();\r\n            }\r\n        }\r\n        return JSON.stringify(object);\r\n    }\r\n\r\n    static parse(json, p5, playBoard) {\r\n        const object = JSON.parse(json);\r\n        let board = new BoardCells(object.size);\r\n        for (let i = 0; i < object.size; i++) {\r\n            for (let j = 0; j < object.size; j++) {\r\n                board.boardObjects[i][j] = Cell.parse(object.boardObjects[i][j], i, j, p5, playBoard);\r\n            }\r\n        }\r\n        return board;\r\n    }\r\n}\r\n\r\nclass Cell {\r\n    // constructor only involves terrain since\r\n    // we will manually set terrain for all stages\r\n    // but the right to plant is handed over to player.\r\n    constructor(x, y, terrain) {\r\n        if (terrain.type !== itemTypes.TERRAIN) {\r\n            console.error(`failed to set cell at (${x},${y}) since the input is not terrain.`);\r\n            return;\r\n        }\r\n\r\n        this.x = x;\r\n        this.y = y;\r\n        this._terrain = terrain;\r\n        this._plant = null;\r\n        this._seed = null;\r\n        this._enemy = null;\r\n        this.ecosystem = null;\r\n    }\r\n\r\n    // however we still need to change terrain\r\n    // for game extensibility.\r\n    set terrain(terrain) {\r\n        if (terrain.type !== itemTypes.TERRAIN) {\r\n            console.error(`failed to set cell at (${this.x},${this.y}) since the input is not terrain.`);\r\n            return;\r\n        }\r\n        this._terrain = terrain;\r\n    }\r\n\r\n    get terrain() {\r\n        return this._terrain;\r\n    }\r\n\r\n    // to remove a plant from a cell, use removePlant below.\r\n    set plant(plant) {\r\n        if (plant.type !== itemTypes.PLANT) {\r\n            console.error(`failed to set cell at (${this.x},${this.y}) since the input is not plant.`);\r\n            return;\r\n        }\r\n        this._plant = plant;\r\n    }\r\n\r\n    get plant() {\r\n        return this._plant;\r\n    }\r\n\r\n    removePlant() {\r\n        this._plant = null;\r\n    }\r\n\r\n    set seed(seed) {\r\n        if (seed.type !== itemTypes.SEED) {\r\n            console.error(`failed to set cell at (${this.x},${this.y}) since the input is not seed.`);\r\n            return;\r\n        }\r\n        this._seed = seed;\r\n    }\r\n\r\n    get seed() {\r\n        return this._seed;\r\n    }\r\n\r\n    removeSeed() {\r\n        this._seed = null;\r\n    }\r\n\r\n    set enemy(enemy) {\r\n        this._enemy = enemy;\r\n    }\r\n\r\n    get enemy() {\r\n        return this._enemy;\r\n    }\r\n\r\n    getEcoString(playBoard) {\r\n        if (this.ecosystem === null) {\r\n            return \"The cell is not in an ecosystem.\";\r\n        }\r\n        return this.ecosystem.getEcoString(playBoard);\r\n    }\r\n\r\n    // check if plant or seed is compatible with the terrain, or if the cell is occupied by another plant.\r\n    isCompatible(playBoard, item) {\r\n        if (this.enemy !== null) {\r\n            playBoard.floatingWindow = FloatingWindow.copyOf(playBoard.allFloatingWindows.get(\"010\"));\r\n            return false;\r\n        }\r\n\r\n        if (this.seed !== null || this.plant !== null) {\r\n            playBoard.floatingWindow = FloatingWindow.copyOf(playBoard.allFloatingWindows.get(\"011\"));\r\n            return false;\r\n        }\r\n\r\n        // bamboo\r\n        if (item?.plantType === plantTypes.BAMBOO) {\r\n            if (this.terrain.terrainType === terrainTypes.STEPPE || this.terrain.terrainType === terrainTypes.HILL || this.terrain.terrainType === terrainTypes.LANDSLIDE) {\r\n                return true;\r\n            } else {\r\n                playBoard.floatingWindow = FloatingWindow.copyOf(playBoard.allFloatingWindows.get(\"012\"));\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // plum\r\n        if (item?.plantType === plantTypes.PLUM) {\r\n            if (this.terrain.terrainType === terrainTypes.STEPPE || this.terrain.terrainType === terrainTypes.HILL || this.terrain.terrainType === terrainTypes.SNOWFIELD) {\r\n                return true;\r\n            } else {\r\n                playBoard.floatingWindow = FloatingWindow.copyOf(playBoard.allFloatingWindows.get(\"012\"));\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // other plants\r\n        if (this.terrain.terrainType === terrainTypes.MOUNTAIN || this.terrain.terrainType === terrainTypes.BASE\r\n            || this.terrain.terrainType === terrainTypes.LUMBERING || this.terrain.terrainType === terrainTypes.VOLCANO\r\n            || (this.terrain.terrainType === terrainTypes.LAVA && this.terrain.name === \"Lava\")\r\n            || this.terrain.terrainType === terrainTypes.LANDSLIDE || this.terrain.terrainType === terrainTypes.SNOWFIELD) {\r\n            playBoard.floatingWindow = FloatingWindow.copyOf(playBoard.allFloatingWindows.get(\"012\"));\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    drawTerrain(p5, playBoard) {\r\n        let [x1, y1, x2, y2, x3, y3, x4, y4] = myutil.cellIndex2Pos(p5, playBoard, this.x, this.y, p5.CORNERS);\r\n        p5.image(this.terrain.img, x1 - playBoard.cellWidth / 2, y1, playBoard.cellWidth, playBoard.cellHeight);\r\n\r\n        if (this.ecosystem !== null && playBoard.ecoDisplay) {\r\n            p5.fill('rgba(0%, 0%, 100%, 0.5)');\r\n        } else {\r\n            p5.fill(0, 0, 0, 0);\r\n        }\r\n        p5.stroke(0);\r\n        p5.strokeWeight(2);\r\n        p5.quad(x1, y1, x2, y2, x3, y3, x4, y4);\r\n    }\r\n\r\n\r\n    stringify() {\r\n        let object = {\r\n            terrain: null,\r\n            plant: null,\r\n            seed: null,\r\n            enemy: null,\r\n        }\r\n        if (this.plant) {\r\n            object.plant = this.plant.stringify();\r\n        }\r\n        if (this.seed) {\r\n            object.seed = this.seed.stringify();\r\n        }\r\n        if (this.terrain) {\r\n            object.terrain = this.terrain.stringify();\r\n        }\r\n        if (this.enemy) {\r\n            object.enemy = this.enemy.stringify();\r\n        }\r\n        return JSON.stringify(object);\r\n    }\r\n\r\n    static parse(json, x, y, p5, playBoard) {\r\n        let object = JSON.parse(json);\r\n        let plant, terrain, seed;\r\n        if (object.plant) {\r\n            plant = JSON.parse(object.plant);\r\n            switch (plant.plantType) {\r\n                case plantTypes.TREE:\r\n                    plant = Tree.parse(object.plant, p5);\r\n                    break;\r\n                case plantTypes.BUSH:\r\n                    plant = Bush.parse(object.plant, p5);\r\n                    break;\r\n                case plantTypes.ORCHID:\r\n                    plant = Orchid.parse(object.plant, p5);\r\n                    break;\r\n                case plantTypes.FIRE_HERB:\r\n                    plant = FireHerb.parse(object.plant, p5);\r\n                    break;\r\n                case plantTypes.BAMBOO:\r\n                    plant = Bamboo.parse(object.plant, p5);\r\n                    break;\r\n                case plantTypes.PLUM:\r\n                    plant = Plum.parse(object.plant, p5);\r\n                    break;\r\n                case plantTypes.KIKU:\r\n                    plant = Kiku.parse(object.plant, p5);\r\n                    break;\r\n            }\r\n        }\r\n        if (object.seed) {\r\n            seed = JSON.parse(object.seed);\r\n            switch (seed.seedType) {\r\n                case seedTypes.TREE:\r\n                    seed = TreeSeed.parse(object.seed, p5);\r\n                    break;\r\n                case seedTypes.BUSH:\r\n                    seed = BushSeed.parse(object.seed, p5);\r\n                    break;\r\n                case seedTypes.ORCHID:\r\n                    seed = OrchidSeed.parse(object.seed, p5);\r\n                    break;\r\n                case seedTypes.FIRE_HERB:\r\n                    seed = FireHerbSeed.parse(object.seed, p5);\r\n                    break;\r\n                case seedTypes.BAMBOO:\r\n                    seed = BambooSeed.parse(object.seed, p5);\r\n                    break;\r\n                case seedTypes.PLUM:\r\n                    seed = PlumSeed.parse(object.seed, p5);\r\n                    break;\r\n                case seedTypes.KIKU:\r\n                    seed = KikuSeed.parse(object.seed, p5);\r\n                    break;\r\n            }\r\n        }\r\n        if (object.terrain) {\r\n            terrain = JSON.parse(object.terrain);\r\n            switch (terrain.terrainType) {\r\n                case terrainTypes.BASE:\r\n                    terrain = new PlayerBase(p5);\r\n                    break;\r\n                case terrainTypes.MOUNTAIN:\r\n                    terrain = new Mountain(p5);\r\n                    break;\r\n                case terrainTypes.STEPPE:\r\n                    terrain = new Steppe(p5);\r\n                    break;\r\n                case terrainTypes.LUMBERING:\r\n                    terrain = new Lumbering(p5);\r\n                    break;\r\n                case terrainTypes.VOLCANO:\r\n                    terrain = new Volcano(p5);\r\n                    break;\r\n                case terrainTypes.LAVA:\r\n                    terrain = Lava.parse(object.terrain, p5, playBoard);\r\n                    break;\r\n                case terrainTypes.HILL:\r\n                    terrain = new Hill(p5);\r\n                    break;\r\n                case terrainTypes.LANDSLIDE:\r\n                    terrain = new Landslide(p5);\r\n                    break;\r\n                case terrainTypes.SNOWFIELD:\r\n                    terrain = new Snowfield(p5);\r\n                    break;\r\n                case terrainTypes.SEA:\r\n                    terrain = new Sea(p5);\r\n                    break;\r\n            }\r\n        }\r\n        let cell = new Cell(x, y, terrain);\r\n        if (plant) cell.plant = plant;\r\n        if (seed) cell.seed = seed;\r\n        return cell;\r\n    }\r\n}\r\n\r\nclass Ecosystem {\r\n    constructor(countPlants) {\r\n        this.countPlants = countPlants;\r\n        this.growFaster = true;\r\n        this.rejectLava = false;\r\n        this.strengthenOrchid = false;\r\n        this.withstandSnow = false;\r\n    }\r\n\r\n    getEcoString(playBoard) {\r\n        let str = \"\";\r\n        // str += `${this.countPlants} plants in this ecosystem. `;\r\n        if (this.growFaster) {\r\n            str += \"Seeds sowed here will grow faster. \"\r\n        }\r\n        if (this.rejectLava && (playBoard.stageGroup === stageGroup.VOLCANO || playBoard.stageGroup === stageGroup.TSUNAMI)) {\r\n            str += \"Lava expanded here will stop. \"\r\n        }\r\n        if (this.strengthenOrchid) {\r\n            str += \"Orchid deals more damage to bandits. \"\r\n        }\r\n        if (this.withstandSnow && (playBoard.stageGroup === stageGroup.VOLCANO || playBoard.stageGroup === stageGroup.TSUNAMI)) {\r\n            str += \"Withstand blizzard. \"\r\n        }\r\n        return str;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/model/BoardCells.js b/docs/src/model/BoardCells.js
--- a/docs/src/model/BoardCells.js	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ b/docs/src/model/BoardCells.js	(date 1744215531303)
@@ -17,6 +17,7 @@
 import {Hill, Landslide} from "../items/Earthquake.js";
 import {Sea} from "../items/Sea.js";
 import {Kiku, KikuSeed} from "../items/Kiku.js";
+import {Palm, PalmSeed} from "../items/Palm.js";
 
 export class BoardCells {
     constructor(size) {
@@ -494,6 +495,9 @@
                 case plantTypes.KIKU:
                     plant = Kiku.parse(object.plant, p5);
                     break;
+                case plantTypes.PALM:
+                    plant = Palm.parse(object.plant, p5);
+                    break;
             }
         }
         if (object.seed) {
@@ -520,6 +524,8 @@
                 case seedTypes.KIKU:
                     seed = KikuSeed.parse(object.seed, p5);
                     break;
+                case seedTypes.PALM:
+                    seed = PalmSeed.parse(object.seed, p5);
             }
         }
         if (object.terrain) {
Index: docs/src/model/Standby.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {Button} from \"../items/Button.js\";\r\nimport {stateCode, stageGroup} from \"./GameState.js\";\r\nimport {CanvasSize} from \"../CanvasSize.js\";\r\nimport {myutil} from \"../../lib/myutil.js\";\r\nimport {FloatingWindow} from \"./FloatingWindow.js\";\r\nimport {Screen} from \"./Screen.js\";\r\n\r\nexport class StandbyMenu extends Screen {\r\n    constructor(gameState) {\r\n        super(gameState);\r\n    }\r\n\r\n    setup(p5) {\r\n        this.initAllFloatingWindows(p5);\r\n\r\n        let [escX, escY] = myutil.relative2absolute(0.01, 0.01);\r\n        let [escWidth, escHeight] = myutil.relative2absolute(0.09, 0.07);\r\n        let escapeButton = new Button(escX, escY, escWidth, escHeight, \"Escape\");\r\n        escapeButton.onClick = () => {\r\n            this.gameState.setState(stateCode.MENU);\r\n        };\r\n\r\n        let [buttonWidth, buttonHeight] = myutil.relative2absolute(0.15, 0.07);\r\n        let [buttonX, buttonY] = myutil.relative2absolute(0.2, 0.2);\r\n        let buttonInter = myutil.relative2absolute(0.1, 0.1)[1];\r\n\r\n        let stage1Button = new Button(buttonX, buttonY + buttonInter * 0, buttonWidth, buttonHeight, \"Tornado\");\r\n        stage1Button.onClick = () => {\r\n            this.clickedStageButton(p5, stageGroup.TORNADO);\r\n        };\r\n\r\n        let stage2Button = new Button(buttonX, buttonY + buttonInter * 1, buttonWidth, buttonHeight, \"Volcano\");\r\n        stage2Button.onClick = () => {\r\n            if (!p5.keyIsPressed || p5.key !== 'v') {\r\n                if (!this.gameState.isStageCleared(stageGroup.TORNADO)) {\r\n                    this.copyFloatingWindow(p5, \"lock\");\r\n                    return;\r\n                }\r\n            }\r\n            this.clickedStageButton(p5, stageGroup.VOLCANO);\r\n        };\r\n\r\n        // earthquake + landslide\r\n        let stage3Button = new Button(buttonX, buttonY + buttonInter * 2, buttonWidth, buttonHeight, \"Earthquake\");\r\n        stage3Button.onClick = () => {\r\n            if (!p5.keyIsPressed || p5.key !== 'v') {\r\n                if (!this.gameState.isStageCleared(stageGroup.VOLCANO)) {\r\n                    this.copyFloatingWindow(p5, \"lock\");\r\n                    return;\r\n                }\r\n            }\r\n            this.clickedStageButton(p5, stageGroup.EARTHQUAKE);\r\n        };\r\n\r\n        // landslide + random lightning attack\r\n        let stage4Button = new Button(buttonX, buttonY + buttonInter * 3, buttonWidth, buttonHeight, \"Blizzard\");\r\n        stage4Button.onClick = () => {\r\n            if (!p5.keyIsPressed || p5.key !== 'v') {\r\n                if (!this.gameState.isStageCleared(stageGroup.EARTHQUAKE)) {\r\n                    this.copyFloatingWindow(p5, \"lock\");\r\n                    return;\r\n                }\r\n            }\r\n            this.clickedStageButton(p5, stageGroup.BLIZZARD);\r\n        };\r\n\r\n        // earthquake induced tsunami + rainstorm + landslide + random lighting + tornado\r\n        let stage5Button = new Button(buttonX, buttonY + buttonInter * 4, buttonWidth, buttonHeight, \"Tsunami\");\r\n        stage5Button.onClick = () => {\r\n            if (!p5.keyIsPressed || p5.key !== 'v') {\r\n                if (!this.gameState.isStageCleared(stageGroup.BLIZZARD)) {\r\n                    this.copyFloatingWindow(p5, \"lock\");\r\n                    return;\r\n                }\r\n            }\r\n            this.clickedStageButton(p5, stageGroup.TSUNAMI);\r\n        };\r\n\r\n        this.buttons.push(escapeButton, stage1Button, stage2Button, stage3Button, stage4Button, stage5Button);\r\n    }\r\n\r\n    handleClick(p5) {\r\n        if (this.handleFloatingWindow()) {\r\n            return;\r\n        }\r\n\r\n        for (let button of this.buttons) {\r\n            button.mouseClick(p5);\r\n        }\r\n    }\r\n\r\n    draw(p5) {\r\n        p5.background(80);\r\n        p5.fill(255);\r\n        p5.textSize(32);\r\n        p5.textAlign(p5.CENTER, p5.TOP);\r\n        let [textX, textY] = myutil.relative2absolute(0.5, 0.1);\r\n        p5.text(\"Select Stage\", textX, textY);\r\n\r\n        for (let button of this.buttons) {\r\n            button.draw(p5);\r\n        }\r\n\r\n        this.gameState.inventory.draw(p5, CanvasSize.getSize()[0], CanvasSize.getSize()[1]);\r\n\r\n        this.drawFloatingWindow(p5);\r\n    }\r\n\r\n    clickedStageButton(p5, stageGroup) {\r\n        if (this.gameState.isStageCleared(stageGroup)) {\r\n            this.copyFloatingWindow(p5, \"clear\");\r\n            return;\r\n        }\r\n        this.gameState.setState(stateCode.PLAY);\r\n        this.gameState.currentStageGroup = stageGroup;\r\n    }\r\n\r\n    copyFloatingWindow(p5, str) {\r\n        this.floatingWindow = FloatingWindow.copyOf(this.allFloatingWindows.get(str));\r\n    }\r\n\r\n    setFloatingWindow(p5) {\r\n        if (this.allFloatingWindows.has(\"moreTutorial\") && this.gameState.isSpecificStageCleared(stageGroup.TORNADO, 1)) {\r\n            this.floatingWindow = this.allFloatingWindows.get(\"moreTutorial\");\r\n            this.allFloatingWindows.delete(\"moreTutorial\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    initAllFloatingWindows(p5) {\r\n        let afw = new Map();\r\n\r\n        afw.set(\"clear\", new FloatingWindow(p5, null, \"{white:This stage has been cleared.}\", {\r\n            x: myutil.relative2absolute(1 / 2, 1 / 4)[0],\r\n            y: myutil.relative2absolute(1 / 2, 1 / 4)[1],\r\n            fontSize: 20,\r\n            padding: 10,\r\n            spacingRatio: 0.3,\r\n            fadingSpeed: 1,\r\n            playerCanClick: true\r\n        }));\r\n\r\n        afw.set(\"lock\", new FloatingWindow(p5, null, \"{white:This stage is locked.}\", {\r\n            x: myutil.relative2absolute(1 / 2, 1 / 4)[0],\r\n            y: myutil.relative2absolute(1 / 2, 1 / 4)[1],\r\n            fontSize: 20,\r\n            padding: 10,\r\n            spacingRatio: 0.3,\r\n            fadingSpeed: 1,\r\n            playerCanClick: true\r\n        }));\r\n\r\n        afw.set(\"moreTutorial\", new FloatingWindow(p5, null, \"{white:Click 'Tornado' again to continue tutorial.}\", {\r\n            x: myutil.relative2absolute(1 / 2, 1 / 4)[0],\r\n            y: myutil.relative2absolute(1 / 2, 1 / 4)[1],\r\n            fontSize: 20,\r\n            padding: 10,\r\n            spacingRatio: 0.3,\r\n            fadingSpeed: 1,\r\n            playerCanClick: true\r\n        }));\r\n\r\n        this.allFloatingWindows = afw;\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/model/Standby.js b/docs/src/model/Standby.js
--- a/docs/src/model/Standby.js	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ b/docs/src/model/Standby.js	(date 1744215531308)
@@ -1,116 +1,153 @@
-import {Button} from "../items/Button.js";
 import {stateCode, stageGroup} from "./GameState.js";
 import {CanvasSize} from "../CanvasSize.js";
 import {myutil} from "../../lib/myutil.js";
 import {FloatingWindow} from "./FloatingWindow.js";
 import {Screen} from "./Screen.js";
+import {MapButton} from "../items/MapButton.js";
 
 export class StandbyMenu extends Screen {
     constructor(gameState) {
         super(gameState);
+        this.background = null;
+        this.selectedStageGroup = stageGroup.NO_STAGE;
     }
 
     setup(p5) {
+        this.background = p5.images.get("GameMapBG");
+
         this.initAllFloatingWindows(p5);
 
-        let [escX, escY] = myutil.relative2absolute(0.01, 0.01);
-        let [escWidth, escHeight] = myutil.relative2absolute(0.09, 0.07);
-        let escapeButton = new Button(escX, escY, escWidth, escHeight, "Escape");
-        escapeButton.onClick = () => {
-            this.gameState.setState(stateCode.MENU);
-        };
-
-        let [buttonWidth, buttonHeight] = myutil.relative2absolute(0.15, 0.07);
-        let [buttonX, buttonY] = myutil.relative2absolute(0.2, 0.2);
-        let buttonInter = myutil.relative2absolute(0.1, 0.1)[1];
-
-        let stage1Button = new Button(buttonX, buttonY + buttonInter * 0, buttonWidth, buttonHeight, "Tornado");
-        stage1Button.onClick = () => {
-            this.clickedStageButton(p5, stageGroup.TORNADO);
-        };
-
-        let stage2Button = new Button(buttonX, buttonY + buttonInter * 1, buttonWidth, buttonHeight, "Volcano");
-        stage2Button.onClick = () => {
-            if (!p5.keyIsPressed || p5.key !== 'v') {
-                if (!this.gameState.isStageCleared(stageGroup.TORNADO)) {
-                    this.copyFloatingWindow(p5, "lock");
-                    return;
-                }
-            }
-            this.clickedStageButton(p5, stageGroup.VOLCANO);
-        };
+        const buttonConfigs = [
+            {x: 0.52, y: 0.68, image: "Tornado", group: stageGroup.TORNADO},
+            {x: 0.475, y: 0.475, image: "VolcanoLayer", group: stageGroup.VOLCANO},
+            {x: 0.65, y: 0.3, image: "Landslide", group: stageGroup.EARTHQUAKE},
+            {x: 0.18, y: 0.65, image: "Blizzard", group: stageGroup.BLIZZARD},
+            {x: 0.36, y: 0.3, image: "Tsunami", group: stageGroup.TSUNAMI}
+        ];
 
-        // earthquake + landslide
-        let stage3Button = new Button(buttonX, buttonY + buttonInter * 2, buttonWidth, buttonHeight, "Earthquake");
-        stage3Button.onClick = () => {
-            if (!p5.keyIsPressed || p5.key !== 'v') {
-                if (!this.gameState.isStageCleared(stageGroup.VOLCANO)) {
-                    this.copyFloatingWindow(p5, "lock");
-                    return;
-                }
-            }
-            this.clickedStageButton(p5, stageGroup.EARTHQUAKE);
-        };
+        this.buttons = buttonConfigs.map(cfg => this.createStageButton(p5, cfg.x, cfg.y, cfg.image, cfg.group));
+    }
 
-        // landslide + random lightning attack
-        let stage4Button = new Button(buttonX, buttonY + buttonInter * 3, buttonWidth, buttonHeight, "Blizzard");
-        stage4Button.onClick = () => {
+    createStageButton(p5, xRatio, yRatio, imgName, group) {
+        let [x, y] = myutil.relative2absolute(xRatio, yRatio);
+        let [size] = myutil.relative2absolute(0.05, 0.05);
+        let button = new MapButton(x, y, size, p5.images.get(imgName), group);
+        button.onClick = () => {
             if (!p5.keyIsPressed || p5.key !== 'v') {
-                if (!this.gameState.isStageCleared(stageGroup.EARTHQUAKE)) {
-                    this.copyFloatingWindow(p5, "lock");
+                if (button.isLocked) {
+                    if (button.isCleared) {
+                        this.copyFloatingWindow(p5, "clear");
+                    } else {
+                        this.copyFloatingWindow(p5, "lock");
+                    }
+                    this.selectedStageGroup = stageGroup.NO_STAGE;
                     return;
                 }
             }
-            this.clickedStageButton(p5, stageGroup.BLIZZARD);
-        };
-
-        // earthquake induced tsunami + rainstorm + landslide + random lighting + tornado
-        let stage5Button = new Button(buttonX, buttonY + buttonInter * 4, buttonWidth, buttonHeight, "Tsunami");
-        stage5Button.onClick = () => {
-            if (!p5.keyIsPressed || p5.key !== 'v') {
-                if (!this.gameState.isStageCleared(stageGroup.BLIZZARD)) {
-                    this.copyFloatingWindow(p5, "lock");
-                    return;
-                }
+            if (this.selectedStageGroup === group) {
+                button.circle = null;
+                this.selectedStageGroup = stageGroup.NO_STAGE;
+                this.clickedStageButton(p5, group);
+            } else {
+                this.selectedStageGroup = group;
+                button.createNewCircle(p5);
             }
-            this.clickedStageButton(p5, stageGroup.TSUNAMI);
         };
-
-        this.buttons.push(escapeButton, stage1Button, stage2Button, stage3Button, stage4Button, stage5Button);
+        return button;
     }
 
     handleClick(p5) {
+        // clear circles for every click
+        this.buttons.forEach(button => button.circle = null);
+
         if (this.handleFloatingWindow()) {
             return;
         }
 
         for (let button of this.buttons) {
-            button.mouseClick(p5);
+            if (button.mouseClick(p5)) {
+                return;
+            }
         }
+
+        // clear selected stage group. if a button is clicked, this line of code will not be reached
+        this.selectedStageGroup = stageGroup.NO_STAGE;
     }
 
     draw(p5) {
-        p5.background(80);
-        p5.fill(255);
-        p5.textSize(32);
-        p5.textAlign(p5.CENTER, p5.TOP);
-        let [textX, textY] = myutil.relative2absolute(0.5, 0.1);
-        p5.text("Select Stage", textX, textY);
+        let canvasSize = CanvasSize.getSize();
+        p5.image(this.background, 0, 0, canvasSize[0], canvasSize[1]);
 
         for (let button of this.buttons) {
+            button.unlock(this.gameState);
             button.draw(p5);
         }
 
-        this.gameState.inventory.draw(p5, CanvasSize.getSize()[0], CanvasSize.getSize()[1]);
+        this.gameState.inventory.draw(p5, myutil.relative2absolute(1, 1)[0], myutil.relative2absolute(1, 1)[1]);
+
+        if (this.selectedStageGroup !== stageGroup.NO_STAGE) {
+            this.drawStageInfo(p5, this.selectedStageGroup);
+        }
 
         this.drawFloatingWindow(p5);
     }
 
+    drawStageInfo(p5, group) {
+        let [paddingX, paddingY] = myutil.relative2absolute(1 / 128, 1 / 72);
+        let boxWidth = myutil.relative2absolute(0.15, 1 / 4)[0];
+        let boxHeight = 10 * paddingY;
+        let boxX = myutil.relative2absolute(1, 1)[0] - boxWidth - paddingX;
+        let boxY = myutil.relative2absolute(1, 1)[1] - boxHeight - paddingY;
+
+        p5.fill(100, 100, 100, 200);
+        p5.noStroke();
+        p5.rect(boxX, boxY, boxWidth, boxHeight, 10); // 10: corner roundness
+
+        let progress = this.gameState.clearedStages.get(group) || 0;
+        let total = this.gameState.gsf.stageClasses[group].length;
+
+        let text = "";
+        let enemy = "";
+        switch (group) {
+            case stageGroup.TORNADO:
+                enemy = "tornado";
+                text = "Calamitas Caeli";
+                break;
+            case stageGroup.VOLCANO:
+                enemy = "volcano";
+                text = "Ira Ignis";
+                break;
+            case stageGroup.EARTHQUAKE:
+                enemy = "earthquake";
+                text = "Locus Lapsus";
+                break;
+            case stageGroup.BLIZZARD:
+                enemy = "blizzard";
+                text = "Nix Nefasta";
+                break;
+            case stageGroup.TSUNAMI:
+                enemy = "tsunami";
+                text = "Ultima Unda";
+                break;
+        }
+
+        p5.fill("rgb(255, 255, 128)");
+        p5.textAlign(p5.CENTER, p5.TOP);
+        p5.textSize(20);
+        p5.text(`${enemy}`, boxX + boxWidth / 2, boxY + paddingY);
+        p5.textSize(16);
+        p5.text(`"${text}"`, boxX + boxWidth / 2, boxY + 3 * paddingY);
+        p5.textSize(20);
+        p5.text(`progress:`, boxX + boxWidth / 2, boxY + 5 * paddingY);
+
+        myutil.drawHealthBar(p5, {
+            health: progress,
+            maxHealth: total
+        }, boxX + 2 * paddingX, boxY + 8 * paddingY, boxWidth - 4 * paddingX, paddingY);
+
+    }
+
     clickedStageButton(p5, stageGroup) {
-        if (this.gameState.isStageCleared(stageGroup)) {
-            this.copyFloatingWindow(p5, "clear");
-            return;
-        }
         this.gameState.setState(stateCode.PLAY);
         this.gameState.currentStageGroup = stageGroup;
     }
@@ -162,5 +199,4 @@
 
         this.allFloatingWindows = afw;
     }
-}
-
+}
\ No newline at end of file
Index: docs/src/model/PauseMenu.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {Button} from \"../items/Button.js\";\r\nimport {myutil} from \"../../lib/myutil.js\";\r\nimport {GameSave} from \"./GameSave.js\";\r\nimport {stateCode} from \"./GameState.js\";\r\n\r\nexport class PauseMenu {\r\n    constructor(gameState) {\r\n        this.gameState = gameState;\r\n        this.buttons = [];\r\n    }\r\n\r\n    setup(p5) {\r\n\r\n        let [buttonWidth, buttonHeight] = myutil.relative2absolute(0.15, 0.07);\r\n        let [buttonX, buttonY] = myutil.relative2absolute(0.5, 0.3);\r\n        let buttonInter = myutil.relative2absolute(0.1, 0.1)[1];\r\n\r\n        let continueButton = new Button(buttonX - buttonWidth / 2, buttonY, buttonWidth, buttonHeight, \"Continue\");\r\n        continueButton.onClick = () => {\r\n            this.gameState.togglePaused();\r\n        }\r\n\r\n         let loadGameButton = new Button(buttonX - buttonWidth / 2, buttonY + buttonInter, buttonWidth, buttonHeight, \"Load Game\");\r\n         loadGameButton.onClick = () => {\r\n             GameSave.load(p5);\r\n             this.gameState.togglePaused();\r\n             console.log(p5.controller.gameState.currentStage)\r\n         }\r\n\r\n        let saveGameButton = new Button(buttonX - buttonWidth / 2, buttonY + 2 * buttonInter, buttonWidth, buttonHeight, \"Save Game\");\r\n        saveGameButton.onClick = () => {\r\n            GameSave.save(p5);\r\n            this.gameState.togglePaused();\r\n            console.log(p5.controller.gameState.currentStage)\r\n        }\r\n\r\n        let escapeButton = new Button(buttonX - buttonWidth / 2, buttonY + 3 * buttonInter, buttonWidth, buttonHeight, \"Quit\");\r\n        escapeButton.onClick = () => {\r\n            this.gameState.togglePaused();\r\n            this.gameState.setState(stateCode.STANDBY);\r\n            this.gameState.setPlayerCanClick(true);\r\n        };\r\n        this.buttons.push(continueButton, loadGameButton, saveGameButton, escapeButton);\r\n    }\r\n\r\n    handleClick(p5) {\r\n        for (let button of this.buttons) {\r\n            if (button.mouseClick(p5)) {\r\n                return;\r\n            }\r\n        }\r\n        this.gameState.togglePaused();\r\n    }\r\n\r\n    handleKey() {\r\n\r\n    }\r\n\r\n    draw(p5) {\r\n        p5.background(0, 0, 0, 80);\r\n        p5.fill(255);\r\n        p5.textSize(50);\r\n        p5.textAlign(p5.CENTER, p5.CENTER);\r\n        let [textX, textY] = myutil.relative2absolute(0.5, 0.2);\r\n        p5.text(\"PAUSE\", textX, textY);\r\n\r\n        for (let button of this.buttons) {\r\n            button.draw(p5);\r\n        }\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/model/PauseMenu.js b/docs/src/model/PauseMenu.js
--- a/docs/src/model/PauseMenu.js	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ b/docs/src/model/PauseMenu.js	(date 1744215531307)
@@ -10,7 +10,6 @@
     }
 
     setup(p5) {
-
         let [buttonWidth, buttonHeight] = myutil.relative2absolute(0.15, 0.07);
         let [buttonX, buttonY] = myutil.relative2absolute(0.5, 0.3);
         let buttonInter = myutil.relative2absolute(0.1, 0.1)[1];
@@ -20,24 +19,27 @@
             this.gameState.togglePaused();
         }
 
-         let loadGameButton = new Button(buttonX - buttonWidth / 2, buttonY + buttonInter, buttonWidth, buttonHeight, "Load Game");
-         loadGameButton.onClick = () => {
-             GameSave.load(p5);
-             this.gameState.togglePaused();
-             console.log(p5.controller.gameState.currentStage)
-         }
+        let loadGameButton = new Button(buttonX - buttonWidth / 2, buttonY + buttonInter, buttonWidth, buttonHeight, "Load Game");
+        loadGameButton.onClick = () => {
+            GameSave.load(p5);
+            this.gameState.togglePaused();
+        }
 
         let saveGameButton = new Button(buttonX - buttonWidth / 2, buttonY + 2 * buttonInter, buttonWidth, buttonHeight, "Save Game");
         saveGameButton.onClick = () => {
             GameSave.save(p5);
             this.gameState.togglePaused();
-            console.log(p5.controller.gameState.currentStage)
         }
 
-        let escapeButton = new Button(buttonX - buttonWidth / 2, buttonY + 3 * buttonInter, buttonWidth, buttonHeight, "Quit");
+        let escapeText = this.gameState.state === stateCode.PLAY ? 'Quit' : 'Back';
+        let escapeButton = new Button(buttonX - buttonWidth / 2, buttonY + 3 * buttonInter, buttonWidth, buttonHeight, escapeText);
         escapeButton.onClick = () => {
             this.gameState.togglePaused();
-            this.gameState.setState(stateCode.STANDBY);
+            if (this.gameState.state === stateCode.PLAY) {
+                this.gameState.setState(stateCode.STANDBY);
+            } else {
+                this.gameState.setState(stateCode.MENU);
+            }
             this.gameState.setPlayerCanClick(true);
         };
         this.buttons.push(continueButton, loadGameButton, saveGameButton, escapeButton);
@@ -52,10 +54,6 @@
         this.gameState.togglePaused();
     }
 
-    handleKey() {
-
-    }
-
     draw(p5) {
         p5.background(0, 0, 0, 80);
         p5.fill(255);
Index: docs/src/items/Button.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>export class Button {\r\n    constructor(x, y, width, height, text) {\r\n        // location and size properties\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.text = text;\r\n        // mouse status\r\n        this.isHovered = false;\r\n        this._onClick = (p5) => {\r\n            console.error(\"button's onClick function is not overridden\");\r\n        };\r\n    }\r\n\r\n    draw(p5) {\r\n        p5.push();\r\n        this.isHovered = this.hasMouseOver(p5);\r\n        let baseColor = p5.color(100, 150, 255);\r\n        let hoverColor = p5.color(150, 200, 255);\r\n        let buttonColor = this.isHovered ? hoverColor : baseColor;\r\n        p5.drawingContext.shadowBlur = this.isHovered ? 15 : 5;\r\n        p5.drawingContext.shadowColor = p5.color(0, 0, 0, 50);\r\n        // rectangle shape of button\r\n        p5.noStroke();\r\n        p5.fill(buttonColor);\r\n        p5.rect(this.x, this.y, this.width, this.height, 10); // 10: corner roundedness\r\n        // inner text\r\n        p5.fill(255);\r\n        p5.textSize(18);\r\n        p5.textAlign(p5.CENTER, p5.CENTER);\r\n        p5.text(this.text, this.x + this.width / 2, this.y + this.height / 2);\r\n        p5.pop();\r\n    }\r\n\r\n    set onClick(func) {\r\n        this._onClick = func;\r\n    }\r\n\r\n    hasMouseOver(p5) {\r\n        return p5.mouseX > this.x && p5.mouseX < this.x + this.width\r\n            && p5.mouseY > this.y && p5.mouseY < this.y + this.height;\r\n    }\r\n\r\n    mouseClick(p5) {\r\n        if (this.hasMouseOver(p5)) {\r\n            this._onClick(p5);\r\n            // p5.mySounds.get(\"click\").play();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/items/Button.js b/docs/src/items/Button.js
--- a/docs/src/items/Button.js	(revision 318e39eb80a2cd0c8be00670792e5db009029429)
+++ b/docs/src/items/Button.js	(date 1744215531301)
@@ -14,10 +14,9 @@
     }
 
     draw(p5) {
-        p5.push();
         this.isHovered = this.hasMouseOver(p5);
-        let baseColor = p5.color(100, 150, 255);
-        let hoverColor = p5.color(150, 200, 255);
+        let baseColor = "rgb(100, 150, 255)";
+        let hoverColor = "rgb(150, 200, 255)";
         let buttonColor = this.isHovered ? hoverColor : baseColor;
         p5.drawingContext.shadowBlur = this.isHovered ? 15 : 5;
         p5.drawingContext.shadowColor = p5.color(0, 0, 0, 50);
@@ -30,7 +29,6 @@
         p5.textSize(18);
         p5.textAlign(p5.CENTER, p5.CENTER);
         p5.text(this.text, this.x + this.width / 2, this.y + this.height / 2);
-        p5.pop();
     }
 
     set onClick(func) {
