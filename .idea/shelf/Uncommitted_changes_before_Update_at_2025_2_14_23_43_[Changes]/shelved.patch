Index: docs/src/model/Play.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import { CanvasSize } from \"../CanvasSize.js\";\r\nimport { myutil } from \"../../lib/myutil.js\";\r\nimport { Button } from \"../items/Button.js\";\r\nimport { stateCode,stageCode } from \"./GameState.js\";\r\nimport { BoardCells } from \"./BoardCells.js\";\r\n\r\nexport class PlayBoard {\r\n\r\n    constructor(gameState) {\r\n        this.gameState = gameState;\r\n        this.stageCode = stageCode.NOSTAGE;\r\n        this.canvasWidth = CanvasSize.getSize()[0];\r\n        this.canvasHeight = CanvasSize.getSize()[1];\r\n\r\n        // transformation parameters\r\n        this.Sx = 0.5;\r\n        this.Sy = 0.5;\r\n        this.rot = Math.PI / 6;\r\n        this.span = 2 * Math.PI / 3;\r\n        this.Hy = 1;\r\n\r\n        // grid parameters\r\n        this.gridSize = 8;\r\n        [this.cellWidth, this.cellHeight] = myutil.relative2absolute(1 / 16, 1 / 9);\r\n\r\n        this.buttons = [];\r\n\r\n        // store all enemies\r\n        this.enemies = [];\r\n\r\n        // board objects array and information block indicator\r\n        this.boardObjects = new BoardCells(this.gridSize);\r\n        this.selectedCell = [];\r\n        this.infoStatus = 't';\r\n\r\n        // to store the items at the start of each stage,\r\n        // so when you quit we can reset inventory\r\n        this.tmpInventoryItems = new Map();\r\n\r\n        // turn counter\r\n        this.turn = 1;\r\n        this.maxTurn = 10;\r\n    }\r\n\r\n    /* public methods */\r\n\r\n    setup(p5) {\r\n        let [escX, escY] = myutil.relative2absolute(0.01, 0.01);\r\n        let [escWidth, escHeight] = myutil.relative2absolute(0.09, 0.07);\r\n        let escapeButton = new Button(escX, escY, escWidth, escHeight, \"Escape\");\r\n        escapeButton.onClick = () => {\r\n            this.gameState.setState(stateCode.STANDBY);\r\n        };\r\n        this.buttons.push(escapeButton);\r\n\r\n        // turn button\r\n        let [turnWidth, turnHeight] = myutil.relative2absolute(5 / 32, 0.07);\r\n        let [turnX, turnY] = myutil.relative2absolute(0.5, 0.01);\r\n        let turnButton = new Button(turnX - turnWidth / 2, turnY, turnWidth, turnHeight, this.getTurnButtonText());\r\n        turnButton.onClick = () => {\r\n            this.gameState.togglePlayerCanClick();\r\n            this.gameState.toggleEnemyCanMove();\r\n        }\r\n        this.buttons.push(turnButton);\r\n\r\n        // setup stage terrain\r\n        this.setStageTerrain();\r\n    }\r\n\r\n    handleScroll(event) {\r\n        this.gameState.inventory.handleScroll(event);\r\n    }\r\n\r\n    handleClick(p5) {\r\n\r\n        // clicked info box arrows when they exist\r\n        if(this.selectedCell.length !== 0) {\r\n            if(this.clickInfoBoxArrow(p5)){\r\n                return;\r\n            }else{\r\n                // reset the info status to prevent unintentional bugs\r\n                this.infoStatus = 't';\r\n            }\r\n        }\r\n\r\n        // clicked inventory, then click a cell\r\n        if (this.gameState.inventory.selectedItem !== null) {\r\n            let index = this.pos2CellIndex(p5.mouseX, p5.mouseY);\r\n            let clickedCell = false;\r\n\r\n            if (index[0] !== -1) {\r\n                let row = index[0];\r\n                let col = index[1];\r\n                if (this.boardObjects.getCell(row, col).plant !== null) {\r\n                    return; // prevent repetitive planting one cell\r\n                }\r\n                if (this.boardObjects.plantCell(row, col, this.gameState.inventory.createItem(this.gameState.inventory.selectedItem))) {\r\n                    console.log(`Placed ${this.gameState.inventory.selectedItem} at row ${row}, col ${col}`);\r\n\r\n                    // set plant's skill\r\n                    this.reevaluatePlantSkills(p5);\r\n\r\n                    clickedCell = true;\r\n                }\r\n            }\r\n            // clear inventory's selected item\r\n            if (clickedCell) {\r\n                this.gameState.inventory.itemDecrement();\r\n                // update inventory height\r\n                this.gameState.inventory.updateInventoryHeight();\r\n                return;\r\n            }\r\n        }\r\n        // handle inventory clicks later to prevent unintentional issues\r\n        this.gameState.inventory.handleClick(p5);\r\n\r\n        // click any button\r\n        for (let button of this.buttons) {\r\n            button.mouseClick(p5);\r\n        }\r\n\r\n        // click any grid cell to display info box\r\n        this.clickCells(p5);\r\n    }\r\n\r\n    draw(p5) {\r\n        p5.background(200);\r\n\r\n        if(this.gameState.inventory.selectedItem !== null) {\r\n            p5.cursor('grab');\r\n        }else{\r\n            p5.cursor(p5.ARROW);\r\n        }\r\n\r\n        // draw stage grid\r\n        this.drawGrid(p5);\r\n\r\n        // all buttons\r\n        for (let button of this.buttons) {\r\n            button.draw(p5);\r\n        }\r\n\r\n        // left bottom corner info box\r\n        if (this.selectedCell.length !== 0) {\r\n            this.drawInfoBox(p5);\r\n        }\r\n\r\n        // draw all enemies according to this.enemy\r\n        for (let enemy of this.enemies) {\r\n            let img = this.gameState.images.get(`${enemy.name}`);\r\n            let imgSize = myutil.relative2absolute(1 / 32, 0)[0];\r\n            p5.image(img, enemy.x - imgSize / 2, enemy.y - imgSize, imgSize, imgSize);\r\n            enemy.drawHealthBar(p5, enemy.x - 20, enemy.y - 50, 40, 5);\r\n        }\r\n\r\n        // draw plants according to board objects\r\n        for (let i = 0; i < this.gridSize; i++) {\r\n            for (let j = 0; j < this.gridSize; j++) {\r\n                let cell = this.boardObjects.getCell(i, j);\r\n                let plant = cell.plant;\r\n                if (plant !== null) {\r\n                    let [avgX, avgY] = this.CellIndex2Pos(p5, i, j, p5.CENTER);\r\n                    let img = this.gameState.images.get(`${cell.plant.name}`);\r\n                    let imgSize = myutil.relative2absolute(1 / 32, 0)[0];\r\n                    p5.image(img, avgX - imgSize / 2, avgY - 3 * imgSize / 4, imgSize, imgSize);\r\n                    plant.drawHealthBar(p5, avgX - 21, avgY - 42, 40, 5);\r\n                }\r\n            }\r\n        }\r\n\r\n        // draw inventory\r\n        this.gameState.inventory.draw(p5, this.canvasWidth, this.canvasHeight);\r\n    }\r\n\r\n    /* ----------------------------------- */\r\n    /* ----------------------------------- */\r\n    /* ----------------------------------- */\r\n    /* ----------------------------------- */\r\n    /* below can be treated as black boxes */\r\n    /* ----------------------------------- */\r\n    /* ----------------------------------- */\r\n    /* ----------------------------------- */\r\n    /* ----------------------------------- */\r\n\r\n    // set stage inventory at entering, called by controller\r\n    setStageInventory() {\r\n        console.log(\"setStageInventory is not overridden!\");\r\n    }\r\n\r\n    // set stage terrain, called when the stage is loaded or reset\r\n    setStageTerrain() {\r\n        console.log(\"setStageTerrain is not overridden!\");\r\n    }\r\n\r\n    // when clear or quit, invoke this function to reset board\r\n    // called by controller\r\n    resetBoard() {\r\n        // reset turn and button\r\n        this.turn = 1;\r\n        this.buttons.find(button => button.text.startsWith(\"turn\")).text = this.getTurnButtonText();\r\n\r\n        // reset inventory indicator\r\n        this.selectedCell = [];\r\n\r\n        // clear enemies\r\n        this.enemies = [];\r\n\r\n        // reset info box status\r\n        this.infoStatus = 't';\r\n\r\n        // reset board cells\r\n        this.boardObjects = new BoardCells(this.gridSize);\r\n\r\n        // reset terrain\r\n        this.setStageTerrain();\r\n\r\n        // reset tmp inventory\r\n        this.tmpInventoryItems = null;\r\n    }\r\n\r\n    drawGrid(p5) {\r\n        p5.stroke(0);\r\n        p5.strokeWeight(2);\r\n        let img = this.gameState.images.get(\"ground\");\r\n        let imgSize = myutil.relative2absolute(1 / 32, 0)[0];\r\n\r\n        for (let i = 0; i < this.gridSize; i++) {\r\n            for (let j = 0; j < this.gridSize; j++) {\r\n                let [x1, y1, x2, y2, x3, y3, x4, y4] = this.CellIndex2Pos(p5, i, j, p5.CORNERS);\r\n                p5.image(img, x1 - this.cellWidth/2, y1 , this.cellWidth, this.cellHeight);\r\n\r\n                if (this.boardObjects.getCell(i, j).isEcoSphere) {\r\n                    p5.fill('rgba(0%, 0%, 100%, 0.5)');\r\n                } else {\r\n                    p5.fill(0,0,0,0);\r\n                }\r\n                p5.stroke(0);\r\n                p5.strokeWeight(2);\r\n                p5.quad(x1, y1, x2, y2, x3, y3, x4, y4);\r\n            }\r\n        }\r\n        p5.strokeWeight(0);\r\n    }\r\n\r\n    // set the clicked cell to draw info box\r\n    clickCells(p5) {\r\n        let index = this.pos2CellIndex(p5.mouseX, p5.mouseY);\r\n        if (index[0] === -1) {\r\n            this.selectedCell = [];\r\n        } else {\r\n            this.selectedCell = [index[0], index[1]];\r\n        }\r\n    }\r\n\r\n    // convert canvas position into cell index\r\n    pos2CellIndex(x, y) {\r\n        // edges of the grid under old grid-centered coordinates\r\n        let leftEdge = -(this.gridSize * this.cellWidth) / 2;\r\n        let rightEdge = (this.gridSize * this.cellWidth) / 2;\r\n        let topEdge = -(this.gridSize * this.cellHeight) / 2;\r\n        let bottomEdge = (this.gridSize * this.cellHeight) / 2;\r\n\r\n        // mouse position under old grid-centered coordinates\r\n        let oldX = this.oldCoorX(x - this.canvasWidth / 2, y - this.canvasHeight / 2);\r\n        let oldY = this.oldCoorY(x - this.canvasWidth / 2, y - this.canvasHeight / 2);\r\n\r\n        // Check if click is within the grid\r\n        if (oldX >= leftEdge && oldX <= rightEdge\r\n            && oldY >= topEdge && oldY <= bottomEdge) {\r\n            let col = Math.floor((oldX + (this.gridSize * this.cellWidth) / 2) / this.cellWidth);\r\n            let row = Math.floor((oldY + (this.gridSize * this.cellHeight) / 2) / this.cellHeight);\r\n            return [row, col];\r\n        } else {\r\n            return [-1];\r\n        }\r\n    }\r\n\r\n    // convert cell index into canvas position\r\n    CellIndex2Pos(p5, i, j, mode) {\r\n        let x = -(this.gridSize * this.cellWidth / 2) + j * this.cellWidth;\r\n        let y = -(this.gridSize * this.cellHeight / 2) + i * this.cellHeight;\r\n\r\n        let x1 = this.newCoorX(x, y) + this.canvasWidth / 2;\r\n        let y1 = this.newCoorY(x, y) + this.canvasHeight / 2;\r\n\r\n        if (mode === p5.CORNER) {\r\n            return [x1, y1];\r\n        }\r\n\r\n        let x2 = this.newCoorX(x + this.cellWidth, y) + this.canvasWidth / 2;\r\n        let y2 = this.newCoorY(x + this.cellWidth, y) + this.canvasHeight / 2;\r\n        let x3 = this.newCoorX(x + this.cellWidth, y + this.cellHeight) + this.canvasWidth / 2;\r\n        let y3 = this.newCoorY(x + this.cellWidth, y + this.cellHeight) + this.canvasHeight / 2;\r\n        let x4 = this.newCoorX(x, y + this.cellHeight) + this.canvasWidth / 2;\r\n        let y4 = this.newCoorY(x, y + this.cellHeight) + this.canvasHeight / 2;\r\n\r\n        if (mode === p5.CORNERS) {\r\n            return [x1, y1, x2, y2, x3, y3, x4, y4];\r\n        }\r\n\r\n        if (mode === p5.CENTER) {\r\n            return [(x1 + x2 + x3 + x4) / 4, (y1 + y2 + y3 + y4) / 4];\r\n        }\r\n    }\r\n\r\n    // a finite state machine.\r\n    infoBoxFSM(nextOrPrev){\r\n        let cell = this.boardObjects.getCell(this.selectedCell[0], this.selectedCell[1]);\r\n\r\n        // terrain & enemy\r\n        if(this.infoStatus === 't'){\r\n            if(nextOrPrev === 'n'){\r\n                if(cell.plant !== null){\r\n                    this.infoStatus = 'p';\r\n                }else{\r\n                    this.infoStatus = 'e';\r\n                }\r\n            }else{\r\n                this.infoStatus = 'e';\r\n            }\r\n            return;\r\n        }\r\n\r\n        // plant passive skill\r\n        if(this.infoStatus === 'p'){\r\n            if(nextOrPrev === 'n'){\r\n                this.infoStatus = 'a';\r\n            }else{\r\n                this.infoStatus = 't';\r\n            }\r\n            return;\r\n        }\r\n\r\n        // plant active skill\r\n        if(this.infoStatus === 'a'){\r\n            if(nextOrPrev === 'n'){\r\n                this.infoStatus = 'e';\r\n            }else{\r\n                this.infoStatus = 'p';\r\n            }\r\n            return;\r\n        }\r\n\r\n        // ecosystem\r\n        if(this.infoStatus === 'e'){\r\n            if(nextOrPrev === 'n'){\r\n                this.infoStatus = 't';\r\n            }else{\r\n                if(cell.plant !== null){\r\n                    this.infoStatus = 'a';\r\n                }else{\r\n                    this.infoStatus = 't';\r\n                }\r\n            }\r\n            return;\r\n        }\r\n    }\r\n\r\n    clickInfoBoxArrow(p5){\r\n        // the parameters of arrows are hardcoded now, should refactor later.\r\n        let leftArrowX = 74;\r\n        let rightArrowX = 150.8;\r\n        let arrowY = 494.4;\r\n        let arrowSize = 25.6;\r\n        if(p5.mouseX >= leftArrowX && p5.mouseX < leftArrowX + arrowSize\r\n            && p5.mouseY >= arrowY && p5.mouseY <= arrowY + arrowSize){\r\n            this.infoBoxFSM('p');\r\n            return true;\r\n        }\r\n        if(p5.mouseX >= rightArrowX && p5.mouseX < rightArrowX + arrowSize\r\n            && p5.mouseY >= arrowY && p5.mouseY <= arrowY + arrowSize){\r\n            this.infoBoxFSM('n');\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // left bottom info box\r\n    drawInfoBox(p5) {\r\n        let [boxWidth, boxHeight] = myutil.relative2absolute(0.18, 1 / 4);\r\n        let boxX = myutil.relative2absolute(1 / 128, 0)[0];\r\n        let [paddingX, paddingY] = myutil.relative2absolute(1 / 128, 1 / 72);\r\n        let boxY = this.canvasHeight - boxHeight - paddingY;\r\n\r\n        p5.fill(50);\r\n        p5.noStroke();\r\n        p5.rect(boxX, boxY, boxWidth, boxHeight, 10); // 10: corner roundness\r\n\r\n        let title;\r\n        let info;\r\n\r\n        if(this.infoStatus === 't'){\r\n            title = \"General Info\";\r\n            info = this.boardObjects.getCellString(this.selectedCell[0], this.selectedCell[1]);\r\n        }else if(this.infoStatus === 'p'){\r\n            title = \"Plant Passive\";\r\n            info = this.boardObjects.getCell(this.selectedCell[0], this.selectedCell[1]).plant.getPassiveString();\r\n        }else if(this.infoStatus === 'a'){\r\n            title = \"Plant Active\";\r\n            info = this.boardObjects.getCell(this.selectedCell[0], this.selectedCell[1]).plant.getActiveString();\r\n        }else if(this.infoStatus === 'e'){\r\n            title = \"Ecosystem\";\r\n            info = this.boardObjects.getCell(this.selectedCell[0], this.selectedCell[1]).getEcoString();\r\n        }\r\n\r\n        p5.fill(255);\r\n        p5.textSize(20);\r\n        p5.textAlign(p5.CENTER, p5.TOP);\r\n        p5.text(title, boxX + boxWidth / 2, boxY + paddingY);\r\n\r\n        p5.textSize(18);\r\n        p5.textAlign(p5.LEFT, p5.TOP);\r\n        p5.textWrap(p5.WORD);\r\n        p5.text(info, boxX + paddingX, boxY + paddingY + 24, boxWidth - paddingX * 2);\r\n\r\n        let arrowSize = myutil.relative2absolute(0.02)[0];\r\n        p5.image(this.gameState.images.get(\"leftarrow\"), boxX + boxWidth/3 - arrowSize/2, boxY - arrowSize - paddingY, arrowSize, arrowSize);\r\n        p5.image(this.gameState.images.get(\"rightarrow\"), boxX + 2*boxWidth/3 - arrowSize/2, boxY - arrowSize - paddingY, arrowSize, arrowSize);\r\n    }\r\n\r\n    // end turn enemy activities\r\n    enemyMovements(p5) {\r\n        let updating = false;\r\n\r\n        for (let enemy of this.enemies) {\r\n            if (enemy.enemyMovements(p5, this) === true) {\r\n                updating = true;\r\n            }\r\n            // delete dead enemy\r\n            if (!enemy.status) {\r\n                this.enemies.splice(this.enemies.indexOf(enemy), 1);\r\n            }\r\n        }\r\n\r\n        // still updating?\r\n        if (updating) {\r\n            return;\r\n        }\r\n\r\n        // if all enemies are updated:\r\n        // 1. set new enemies according to turn counter\r\n        this.nextTurnEnemies(p5);\r\n\r\n        // 2. set status\r\n        this.endTurnActivity(p5);\r\n    }\r\n\r\n    // miscellaneous end turn settings\r\n    endTurnActivity(p5) {\r\n        // a safe-lock to remove all dead plants\r\n        let cells = this.boardObjects.getAllCellsWithPlant();\r\n        for (let cell of cells) {\r\n            if (cell.plant.status === false) {\r\n                this.boardObjects.removePlant(cell.x, cell.y);\r\n            }\r\n        }\r\n\r\n        // reevaluate plants' skills\r\n        this.reevaluatePlantSkills();\r\n\r\n        // set turn and counter\r\n        this.turn++;\r\n        this.buttons.find(button => button.text.startsWith(\"turn\")).text = this.getTurnButtonText();\r\n        if (this.turn === this.maxTurn) {\r\n            this.gameState.setState(stateCode.FINISH);\r\n        }\r\n\r\n        // set action listener active\r\n        this.gameState.togglePlayerCanClick();\r\n        this.gameState.toggleEnemyCanMove();\r\n    }\r\n\r\n    nextTurnEnemies(p5){\r\n        console.log(\"nextTurnEnemies is not overridden!\");\r\n    }\r\n\r\n    // when a new plant is placed, or at the end of a turn,\r\n    // we need to verify all plant's skill status.\r\n    reevaluatePlantSkills(p5) {\r\n        let cells = this.boardObjects.getAllCellsWithPlant();\r\n        for (let cell of cells) {\r\n           cell.plant.reevaluateSkills(this, cell);\r\n        }\r\n    }\r\n\r\n    // the coordinate transformation is\r\n    // (x')   ( Sx * cos(rot)  Sy * cos(rot+span) ) ( x )\r\n    // (  ) = (                                   ) (   )\r\n    // (y')   ( Sx * sin(rot)  Sy * sin(rot+span) ) ( y )\r\n\r\n    newCoorX(x, y) {\r\n        return x * this.Sx * Math.cos(this.rot) + y * this.Sy * Math.cos(this.span + this.rot);\r\n    }\r\n\r\n    newCoorY(x, y) {\r\n        return this.Hy * (x * this.Sx * Math.sin(this.rot) + y * this.Sy * Math.sin(this.span + this.rot));\r\n    }\r\n\r\n    oldCoorX(newX, newY) {\r\n        return (1 / (this.Sx * this.Sy * Math.sin(this.span))) * (this.Sy * Math.sin(this.rot + this.span) * newX - this.Sy * Math.cos(this.rot + this.span) * newY);\r\n    }\r\n\r\n    oldCoorY(newX, newY) {\r\n        return -(1 / (this.Sx * this.Sy * Math.sin(this.span))) * (this.Sx * Math.sin(this.rot) * newX - this.Sx * Math.cos(this.rot) * newY);\r\n    }\r\n\r\n    getTurnButtonText() {\r\n        return `turn ${this.turn} in ${this.maxTurn}`;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/src/model/Play.js b/docs/src/model/Play.js
--- a/docs/src/model/Play.js	(revision 48e259b29d67d58522e31fdc299726bf5df57468)
+++ b/docs/src/model/Play.js	(date 1739570107231)
@@ -1,8 +1,8 @@
-import { CanvasSize } from "../CanvasSize.js";
-import { myutil } from "../../lib/myutil.js";
-import { Button } from "../items/Button.js";
-import { stateCode,stageCode } from "./GameState.js";
-import { BoardCells } from "./BoardCells.js";
+import {CanvasSize} from "../CanvasSize.js";
+import {myutil} from "../../lib/myutil.js";
+import {Button} from "../items/Button.js";
+import {stateCode, stageCode} from "./GameState.js";
+import {BoardCells} from "./BoardCells.js";
 
 export class PlayBoard {
 
@@ -19,6 +19,9 @@
         this.span = 2 * Math.PI / 3;
         this.Hy = 1;
 
+        // animation parameters
+        this.tempWidth = 0;
+        this.tempHeight = 0;
         // grid parameters
         this.gridSize = 8;
         [this.cellWidth, this.cellHeight] = myutil.relative2absolute(1 / 16, 1 / 9);
@@ -74,10 +77,10 @@
     handleClick(p5) {
 
         // clicked info box arrows when they exist
-        if(this.selectedCell.length !== 0) {
-            if(this.clickInfoBoxArrow(p5)){
+        if (this.selectedCell.length !== 0) {
+            if (this.clickInfoBoxArrow(p5)) {
                 return;
-            }else{
+            } else {
                 // reset the info status to prevent unintentional bugs
                 this.infoStatus = 't';
             }
@@ -126,9 +129,9 @@
     draw(p5) {
         p5.background(200);
 
-        if(this.gameState.inventory.selectedItem !== null) {
+        if (this.gameState.inventory.selectedItem !== null) {
             p5.cursor('grab');
-        }else{
+        } else {
             p5.cursor(p5.ARROW);
         }
 
@@ -223,22 +226,28 @@
         p5.strokeWeight(2);
         let img = this.gameState.images.get("ground");
         let imgSize = myutil.relative2absolute(1 / 32, 0)[0];
-
+        let tempWidth = 0;
+        let tempHeight = 0;
         for (let i = 0; i < this.gridSize; i++) {
             for (let j = 0; j < this.gridSize; j++) {
                 let [x1, y1, x2, y2, x3, y3, x4, y4] = this.CellIndex2Pos(p5, i, j, p5.CORNERS);
-                p5.image(img, x1 - this.cellWidth/2, y1 , this.cellWidth, this.cellHeight);
+                p5.image(img, x1 - this.cellWidth / 2, y1, this.tempWidth, this.tempHeight);
 
                 if (this.boardObjects.getCell(i, j).isEcoSphere) {
                     p5.fill('rgba(0%, 0%, 100%, 0.5)');
                 } else {
-                    p5.fill(0,0,0,0);
+                    p5.fill(0, 0, 0, 0);
                 }
                 p5.stroke(0);
                 p5.strokeWeight(2);
                 p5.quad(x1, y1, x2, y2, x3, y3, x4, y4);
             }
         }
+        if (this.tempWidth !== this.cellWidth && this.tempHeight !== this.cellHeight) {
+            this.tempWidth += 2;
+            this.tempHeight += 2;
+        }
+        else{}
         p5.strokeWeight(0);
     }
 
@@ -304,51 +313,51 @@
     }
 
     // a finite state machine.
-    infoBoxFSM(nextOrPrev){
+    infoBoxFSM(nextOrPrev) {
         let cell = this.boardObjects.getCell(this.selectedCell[0], this.selectedCell[1]);
 
         // terrain & enemy
-        if(this.infoStatus === 't'){
-            if(nextOrPrev === 'n'){
-                if(cell.plant !== null){
+        if (this.infoStatus === 't') {
+            if (nextOrPrev === 'n') {
+                if (cell.plant !== null) {
                     this.infoStatus = 'p';
-                }else{
+                } else {
                     this.infoStatus = 'e';
                 }
-            }else{
+            } else {
                 this.infoStatus = 'e';
             }
             return;
         }
 
         // plant passive skill
-        if(this.infoStatus === 'p'){
-            if(nextOrPrev === 'n'){
+        if (this.infoStatus === 'p') {
+            if (nextOrPrev === 'n') {
                 this.infoStatus = 'a';
-            }else{
+            } else {
                 this.infoStatus = 't';
             }
             return;
         }
 
         // plant active skill
-        if(this.infoStatus === 'a'){
-            if(nextOrPrev === 'n'){
+        if (this.infoStatus === 'a') {
+            if (nextOrPrev === 'n') {
                 this.infoStatus = 'e';
-            }else{
+            } else {
                 this.infoStatus = 'p';
             }
             return;
         }
 
         // ecosystem
-        if(this.infoStatus === 'e'){
-            if(nextOrPrev === 'n'){
+        if (this.infoStatus === 'e') {
+            if (nextOrPrev === 'n') {
                 this.infoStatus = 't';
-            }else{
-                if(cell.plant !== null){
+            } else {
+                if (cell.plant !== null) {
                     this.infoStatus = 'a';
-                }else{
+                } else {
                     this.infoStatus = 't';
                 }
             }
@@ -356,19 +365,19 @@
         }
     }
 
-    clickInfoBoxArrow(p5){
+    clickInfoBoxArrow(p5) {
         // the parameters of arrows are hardcoded now, should refactor later.
         let leftArrowX = 74;
         let rightArrowX = 150.8;
         let arrowY = 494.4;
         let arrowSize = 25.6;
-        if(p5.mouseX >= leftArrowX && p5.mouseX < leftArrowX + arrowSize
-            && p5.mouseY >= arrowY && p5.mouseY <= arrowY + arrowSize){
+        if (p5.mouseX >= leftArrowX && p5.mouseX < leftArrowX + arrowSize
+            && p5.mouseY >= arrowY && p5.mouseY <= arrowY + arrowSize) {
             this.infoBoxFSM('p');
             return true;
         }
-        if(p5.mouseX >= rightArrowX && p5.mouseX < rightArrowX + arrowSize
-            && p5.mouseY >= arrowY && p5.mouseY <= arrowY + arrowSize){
+        if (p5.mouseX >= rightArrowX && p5.mouseX < rightArrowX + arrowSize
+            && p5.mouseY >= arrowY && p5.mouseY <= arrowY + arrowSize) {
             this.infoBoxFSM('n');
             return true;
         }
@@ -389,16 +398,16 @@
         let title;
         let info;
 
-        if(this.infoStatus === 't'){
+        if (this.infoStatus === 't') {
             title = "General Info";
             info = this.boardObjects.getCellString(this.selectedCell[0], this.selectedCell[1]);
-        }else if(this.infoStatus === 'p'){
+        } else if (this.infoStatus === 'p') {
             title = "Plant Passive";
             info = this.boardObjects.getCell(this.selectedCell[0], this.selectedCell[1]).plant.getPassiveString();
-        }else if(this.infoStatus === 'a'){
+        } else if (this.infoStatus === 'a') {
             title = "Plant Active";
             info = this.boardObjects.getCell(this.selectedCell[0], this.selectedCell[1]).plant.getActiveString();
-        }else if(this.infoStatus === 'e'){
+        } else if (this.infoStatus === 'e') {
             title = "Ecosystem";
             info = this.boardObjects.getCell(this.selectedCell[0], this.selectedCell[1]).getEcoString();
         }
@@ -414,8 +423,8 @@
         p5.text(info, boxX + paddingX, boxY + paddingY + 24, boxWidth - paddingX * 2);
 
         let arrowSize = myutil.relative2absolute(0.02)[0];
-        p5.image(this.gameState.images.get("leftarrow"), boxX + boxWidth/3 - arrowSize/2, boxY - arrowSize - paddingY, arrowSize, arrowSize);
-        p5.image(this.gameState.images.get("rightarrow"), boxX + 2*boxWidth/3 - arrowSize/2, boxY - arrowSize - paddingY, arrowSize, arrowSize);
+        p5.image(this.gameState.images.get("leftarrow"), boxX + boxWidth / 3 - arrowSize / 2, boxY - arrowSize - paddingY, arrowSize, arrowSize);
+        p5.image(this.gameState.images.get("rightarrow"), boxX + 2 * boxWidth / 3 - arrowSize / 2, boxY - arrowSize - paddingY, arrowSize, arrowSize);
     }
 
     // end turn enemy activities
@@ -470,7 +479,7 @@
         this.gameState.toggleEnemyCanMove();
     }
 
-    nextTurnEnemies(p5){
+    nextTurnEnemies(p5) {
         console.log("nextTurnEnemies is not overridden!");
     }
 
@@ -479,7 +488,7 @@
     reevaluatePlantSkills(p5) {
         let cells = this.boardObjects.getAllCellsWithPlant();
         for (let cell of cells) {
-           cell.plant.reevaluateSkills(this, cell);
+            cell.plant.reevaluateSkills(this, cell);
         }
     }
 
