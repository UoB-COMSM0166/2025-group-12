<!DOCTYPE html>
<html lang="en">

<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.11.1/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.11.1/addons/p5.sound.min.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
    <meta charset="utf-8" />
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <main>
    </main>
    <script>
        let cols, rows;
        let spacing = 20;  // 調整間距以適應等軸投影棋盤
        let size = [];
        let moveRange = 5; // 可移動範圍
        let selectedX = -1, selectedY = -1; // 記錄目前滑鼠所在的棋盤格子，設定為-1，避免滑鼠移出棋盤界限

        // Code to run once at the start of the sketch. (Initialize)
        function setup() {
            createCanvas(800, 800);
            rectMode(CENTER);
            cols = width / spacing;
            rows = height / spacing;
        }

        // Code to run repeatedly.
        function draw() {
            background(0);
            updateMousePosition();
            drawGrid();
        }

        //* 更新滑鼠對應的棋盤座標 *//
        function updateMousePosition() {
            // 將 平面座標系，旋轉之後壓縮，對x軸的單位壓縮2倍，對y軸的單位壓縮4倍，即新的網格座標系為旋轉後的且相對扁平的菱形
            //    - gridX = 滑鼠對應的棋盤 x座標(格子)、gridY = 滑鼠對應的棋盤 y座標(格子)
            //    - Math.round()：若 gridX 和 gridY 為非整數，則選擇最近的網格
            //    - mouseX-(width/2)：將滑鼠座標的 X軸，轉換為棋盤的中心基準點
            //    - mouseY-(width/4)：將滑鼠座標的 Y軸，轉換為棋盤的中心基準點
            // Example:
            //   假設畫布大小為 800×800，在原始的平面座標系中，原點為左上角的(0,0)，滑鼠座標為(450,200)，且每個方格的高與寬為 100
            //   將畫布中心點 (width/2, height/2) = (400,400) 改設定為原點，滑鼠座標為(50,200)，每個方格的高與寬為 100
            //   在轉換後的座標系統中，畫布大小為 width/2 × height/4 = 400 × 150，每個方格的高與寬為 (50,25)
            //   最後因為菱形排列的棋盤，每個 X 軸和 Y 軸的變化其實是“對角線方向”，經過調整後可以確保每個棋盤格子正確對應到 gridX, gridY，不會偏移錯誤
            //     1. 調整前：若沒有 “/2”
            //          (0,0)   (1,0)   (2,0)   (3,0)
            //            +----+----+----+----+
            //            |    |    |    |    |
            //          (0,1)   (1,1)   (2,1)   (3,1)
            //            +----+----+----+----+
            //
            //     2. 調整後：等軸投影（/2）
            //             (0,0)       (1,0)       (2,0)       (3,0)
            //               +---------+---------+---------+
            //              /         /         /         /
            //        (0,1)+---------+---------+---------+ (3,1)
            //              \         \         \         \
            //               +---------+---------+---------+

            let gridX = Math.round((mouseX - width / 2) / (spacing / 2) + (mouseY - height / 4) / (spacing / 4)) / 2;
            let gridY = Math.round((mouseY - height / 4) / (spacing / 4) - (mouseX - width / 2) / (spacing / 2)) / 2;


            // 檢查滑鼠是否在有效的棋盤範圍內
            if (gridX >= 0 && gridX < cols && gridY >= 0 && gridY < rows) {
                selectedX = gridX;
                selectedY = gridY;
            } else {
                selectedX = -1;
                selectedY = -1;
            }
        }

        // 繪製棋盤
        function drawGrid() {
            //let centerX = Math.floor(cols/2);
            //let centerY = Math.floor(rows/2);

            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    // 計算等軸投影坐標：棋盤的等軸投影座標系統，往右或往上移動一格，皆會涉及原直角坐標系的x座標和y座標
                    let isoX = (i - j) * spacing / 2 + width / 2;
                    let isoY = (i + j) * spacing / 4 + height / 4;

                    // 檢查是否在移動範圍內
                    if (selectedX !== -1 && selectedY !== -1) {
                        let distance = Math.abs(selectedX - i) + Math.abs(selectedY - j);  // 等軸坐標系中，使用曼哈頓距離來計算位移，及x與y座標的變動量總和
                        if (distance <= moveRange) {
                            fill(0, 255, 0, 150); // 綠色標記可移動區域
                        } else {
                            fill(150, 200, 250); // 普通棋盤顏色
                        }
                    } else {
                        fill(150, 200, 250); // 普通棋盤顏色
                    }

                    // 繪製菱形棋盤
                    quad(
                        isoX, isoY,                          // 上點
                        isoX + spacing / 2, isoY + spacing / 4,  // 右點
                        isoX, isoY + spacing / 2,            // 下點
                        isoX - spacing / 2, isoY + spacing / 4   // 左點
                    );
                    /*
                    // 標記棋盤中心
                    if (i === centerX && j === centerY){
                        fill(255,0,0);
                        ellipse(isoX,isoY,10,10);  // 在中心繪製紅色圓點
                    }
                    */
                }
            }
        }

    </script>
</body>

</html>